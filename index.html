<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wormhole Rolling Calculator</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%230a0a2a'/%3E%3Ccircle cx='50' cy='50' r='40' fill='none' stroke='%234af' stroke-width='3' opacity='0.8'/%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='%2384f' stroke-width='3' opacity='0.6'/%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='%23a4f' stroke-width='3' opacity='0.4'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%23f4a' opacity='0.8'/%3E%3C/svg%3E">
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%230a0a2a'/%3E%3Ccircle cx='50' cy='50' r='40' fill='none' stroke='%234af' stroke-width='3' opacity='0.8'/%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='%2384f' stroke-width='3' opacity='0.6'/%3E%3Ccircle cx='50' cy='50' r='20' fill='none' stroke='%23a4f' stroke-width='3' opacity='0.4'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%23f4a' opacity='0.8'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            min-height: 100vh;
            color: #e0e0ff;
            overflow-x: hidden;
            position: relative;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .wormhole-bg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 800px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        .wormhole-ring {
            position: absolute;
            border: 2px solid;
            border-radius: 50%;
            animation: pulse 4s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(20, 20, 50, 0.8);
            border: 1px solid #4a4a8a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(100, 100, 200, 0.3);
        }

        h1 {
            color: #8af;
            font-size: 1.8em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(136, 170, 255, 0.5);
        }

        .system-info {
            color: #aaa;
            font-size: 0.9em;
        }

        .system-info span {
            color: #6cf;
        }

        .wh-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .spec-card {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .spec-card h3 {
            color: #7af;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .spec-card .value {
            color: #fff;
            font-size: 1.4em;
            font-weight: bold;
        }

        .spec-card .unit {
            color: #888;
            font-size: 0.8em;
        }

        .mass-display {
            background: rgba(20, 20, 50, 0.9);
            border: 2px solid #4a4a8a;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            text-align: center;
        }

        .mass-bar-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            height: 50px;
            margin: 20px 0;
            overflow: visible;
            position: relative;
            border: 1px solid #3a3a6a;
        }

        .mass-bar {
            height: 100%;
            transition: width 0.5s ease, background 0.5s ease;
            border-radius: 10px;
            position: absolute;
            top: 0;
            left: 0;
        }

        .mass-bar.fresh {
            background: linear-gradient(90deg, #2d5a2d, #4a8a4a);
            box-shadow: 0 0 20px rgba(74, 138, 74, 0.5);
        }

        .mass-bar.shrink {
            background: linear-gradient(90deg, #8a6a2d, #c4a044);
            box-shadow: 0 0 20px rgba(196, 160, 68, 0.5);
        }

        .mass-bar.crit {
            background: linear-gradient(90deg, #8a2d2d, #c44444);
            box-shadow: 0 0 20px rgba(196, 68, 68, 0.5);
            animation: critPulse 1s infinite;
        }

        .variance-overlay {
            position: absolute;
            top: 0;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.1) 2px,
                rgba(255, 255, 255, 0.1) 4px
            );
            border-radius: 10px;
            pointer-events: none;
            border-left: 2px dashed rgba(255, 100, 100, 0.8);
            border-right: 2px dashed rgba(100, 255, 100, 0.8);
        }

        .variance-label {
            position: absolute;
            top: -20px;
            font-size: 0.7em;
            white-space: nowrap;
        }

        .variance-label.min {
            color: #f88;
        }

        .variance-label.max {
            color: #8f8;
        }

        @keyframes critPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .mass-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .mass-remaining {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }

        .variance-range {
            font-size: 1em;
            color: #aaa;
            margin-bottom: 10px;
        }

        .variance-range .min { color: #f88; }
        .variance-range .max { color: #8f8; }

        .status-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .status-fresh {
            background: rgba(74, 138, 74, 0.3);
            border: 2px solid #4a8a4a;
            color: #8f8;
        }

        .status-shrink {
            background: rgba(196, 160, 68, 0.3);
            border: 2px solid #c4a044;
            color: #fc8;
        }

        .status-crit {
            background: rgba(196, 68, 68, 0.3);
            border: 2px solid #c44444;
            color: #f88;
            animation: critPulse 1s infinite;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-section {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
        }

        .section-header {
            color: #8af !important;
            margin-bottom: 15px !important;
            font-size: 1.1em !important;
            text-align: left !important;
            border-bottom: none !important;
            padding-bottom: 0 !important;
        }

        .section-header::before {
            content: none !important;
        }

        .setup-label {
            color: #8cf;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .setup-divider {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            color: #666;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setup-divider::before,
        .setup-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, #4a6a8a, transparent);
        }

        /* Hole Setup Section - Overhauled Layout */
        .hole-setup-section {
            background: rgba(40, 80, 60, 0.3);
            border: 2px solid #2a8a6a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .setup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .settings-toggle {
            padding: 6px 12px;
            font-size: 0.85em;
            background: rgba(40, 60, 80, 0.6);
            border: 1px solid #4a6a8a;
            border-radius: 4px;
            color: #8cf;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-toggle:hover {
            background: rgba(50, 70, 90, 0.8);
            border-color: #5a7a9a;
        }

        .session-setup {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setup-group {
            background: rgba(30, 40, 50, 0.4);
            border: 1px solid #3a5a6a;
            border-radius: 8px;
            padding: 15px;
        }

        .primary-cta {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1em;
            font-weight: bold;
            background: linear-gradient(135deg, #2a7a4a, #4aaa6a);
            border: 2px solid #5aca7a;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .primary-cta:hover {
            box-shadow: 0 0 20px rgba(90, 200, 120, 0.4);
            transform: translateY(-1px);
        }

        .setup-settings {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #3a5a6a;
        }

        .settings-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: #888;
            font-size: 0.85em;
            padding: 8px 0;
        }

        .settings-header:hover {
            color: #aaa;
        }

        #settings-summary {
            flex: 1;
            color: #6af;
        }

        .expand-icon {
            transition: transform 0.2s;
        }

        .settings-expanded {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-section h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-cold {
            background: linear-gradient(135deg, #2a4a6a, #3a6a9a);
            color: #adf;
            border: 1px solid #4a8aaa;
        }

        .btn-cold:hover {
            background: linear-gradient(135deg, #3a5a7a, #4a7aaa);
            box-shadow: 0 0 15px rgba(100, 150, 200, 0.5);
        }

        .btn-hot {
            background: linear-gradient(135deg, #6a3a2a, #9a5a3a);
            color: #fca;
            border: 1px solid #aa6a4a;
        }

        .btn-hot:hover {
            background: linear-gradient(135deg, #7a4a3a, #aa6a4a);
            box-shadow: 0 0 15px rgba(200, 100, 80, 0.5);
        }

        .btn-recovery {
            background: linear-gradient(135deg, #4a3a6a, #6a4a9a);
            color: #daf;
            border: 1px solid #8a6aaa;
        }

        .btn-recovery:hover {
            background: linear-gradient(135deg, #5a4a7a, #7a5aaa);
            box-shadow: 0 0 15px rgba(150, 100, 200, 0.5);
        }

        .state-option {
            opacity: 0.6;
        }

        .state-option.selected {
            opacity: 1;
            box-shadow: 0 0 15px rgba(100, 200, 150, 0.5);
            transform: scale(1.02);
        }

        .state-option:hover {
            opacity: 0.9;
        }

        .btn-reset {
            background: linear-gradient(135deg, #3a3a3a, #5a5a5a);
            color: #ccc;
            border: 1px solid #6a6a6a;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #4a4a4a, #6a6a6a);
        }

        .btn-undo {
            background: linear-gradient(135deg, #5a4a2a, #7a6a3a);
            color: #ed9;
            border: 1px solid #8a7a4a;
        }

        .btn-undo:hover {
            background: linear-gradient(135deg, #6a5a3a, #8a7a4a);
        }

        /* Recommended button highlight */
        .jump-btn.recommended {
            box-shadow: 0 0 15px #4a8a4a, 0 0 30px #4a8a4a;
            border-color: #6aca6a !important;
            animation: pulse-glow 1.5s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px #4a8a4a, 0 0 30px #4a8a4a; }
            50% { box-shadow: 0 0 25px #6aca6a, 0 0 45px #4a8a4a; }
        }

        /* Combined Action Panel Layout */
        .action-history-container {
            display: grid;
            grid-template-columns: auto auto 1fr;
            gap: 20px;
            align-items: start;
        }

        .jump-buttons-vertical {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .jump-buttons-vertical .jump-btn {
            padding: 12px 15px;
            font-size: 0.95em;
            white-space: nowrap;
        }

        .inline-history {
            flex: 1;
            min-width: 0;
        }

        .inline-history .history-list {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85em;
        }

        .inline-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #3a5a6a;
        }

        .inline-history-header h4 {
            color: #8af;
            font-size: 0.95em;
            margin: 0;
        }

        @media (max-width: 600px) {
            .action-history-container {
                grid-template-columns: 1fr;
            }
            .jump-buttons-vertical {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            .jump-buttons-vertical .jump-btn {
                flex: 1;
                min-width: 80px;
            }
        }

        /* Observation prompt */
        #observation-prompt {
            background: rgba(60, 40, 20, 0.95);
            border: 2px solid #c4a044;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }

        .observation-question {
            color: #fc8;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .observation-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .observation-buttons button {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid;
            font-weight: bold;
        }

        /* Observation reminder after jump */
        .observation-reminder {
            animation: remind-pulse 2s ease-in-out 3;
        }

        @keyframes remind-pulse {
            0%, 100% {
                background: rgba(60, 40, 20, 0.3);
                box-shadow: none;
            }
            50% {
                background: rgba(100, 80, 40, 0.5);
                box-shadow: 0 0 15px rgba(200, 160, 80, 0.5);
            }
        }

        /* Observation Buttons */
        .observation-buttons-vertical {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 90px;
        }

        .obs-btn {
            padding: 12px 15px;
            font-size: 0.95em;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .obs-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-normal {
            background: linear-gradient(135deg, #3a4a3a, #4a5a4a);
            color: #8f8;
            border: 2px solid #5a7a5a;
        }

        .btn-normal:not(:disabled):hover {
            box-shadow: 0 0 15px rgba(80, 200, 80, 0.4);
        }

        .btn-shrunk {
            background: linear-gradient(135deg, #5a4a2a, #7a6a3a);
            color: #fc8;
            border: 2px solid #9a8a4a;
        }

        .btn-shrunk:not(:disabled):hover {
            box-shadow: 0 0 15px rgba(200, 160, 80, 0.4);
        }

        .btn-crit {
            background: linear-gradient(135deg, #5a2a2a, #7a3a3a);
            color: #f88;
            border: 2px solid #9a4a4a;
        }

        .btn-crit:not(:disabled):hover {
            box-shadow: 0 0 15px rgba(200, 80, 80, 0.4);
        }

        .btn-closed {
            background: linear-gradient(135deg, #2a2a2a, #4a4a4a);
            color: #aaa;
            border: 2px solid #666;
        }

        .btn-closed:not(:disabled):hover {
            box-shadow: 0 0 15px rgba(150, 150, 150, 0.4);
        }

        .obs-btn.required {
            animation: obs-pulse 1.5s ease-in-out infinite;
        }

        @keyframes obs-pulse {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 25px currentColor; }
        }

        .obs-spacer {
            flex: 1;
            min-height: 8px;
        }

        .observation-buttons-vertical .btn-copy,
        .observation-buttons-vertical .btn-undo,
        .observation-buttons-vertical .btn-reset {
            padding: 8px 12px;
            font-size: 0.85em;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid;
            transition: all 0.2s ease;
        }

        .observation-buttons-vertical .btn-copy {
            background: linear-gradient(135deg, #2a4a5a, #3a5a6a);
            color: #8cf;
            border-color: #4a7a9a;
        }

        .observation-buttons-vertical .btn-copy:hover {
            background: linear-gradient(135deg, #3a5a6a, #4a6a7a);
        }

        .observation-buttons-vertical .btn-undo {
            background: linear-gradient(135deg, #5a4a2a, #6a5a3a);
            color: #ed9;
            border-color: #8a7a4a;
        }

        .observation-buttons-vertical .btn-undo:hover {
            background: linear-gradient(135deg, #6a5a3a, #7a6a4a);
        }

        .observation-buttons-vertical .btn-reset {
            background: linear-gradient(135deg, #3a3a3a, #4a4a4a);
            color: #ccc;
            border-color: #6a6a6a;
        }

        .observation-buttons-vertical .btn-reset:hover {
            background: linear-gradient(135deg, #4a4a4a, #5a5a5a);
        }

        /* Monte Carlo Section */
        .monte-carlo {
            background: rgba(20, 40, 60, 0.9);
            border: 2px solid #2a6a8a;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .monte-carlo h3 {
            color: #6cf;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .monte-carlo h3::before {
            content: "ðŸŽ²";
        }

        .simulation-info {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .sequence-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .sequence-card {
            background: rgba(30, 40, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #3a5a7a;
        }

        .sequence-card.safe {
            border-color: #4a8a4a;
            background: rgba(30, 60, 40, 0.8);
        }

        .sequence-card.risky {
            border-color: #8a6a2a;
            background: rgba(60, 50, 30, 0.8);
        }

        .sequence-card.dangerous {
            border-color: #8a3a3a;
            background: rgba(60, 30, 30, 0.8);
        }

        .sequence-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .sequence-detail {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .probability-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .probability-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .probability-fill.safe {
            background: linear-gradient(90deg, #2d8a2d, #4aca4a);
        }

        .probability-fill.risky {
            background: linear-gradient(90deg, #8a6a2d, #caa044);
        }

        .probability-fill.dangerous {
            background: linear-gradient(90deg, #8a2d2d, #ca4444);
        }

        .probability-text {
            font-size: 1.3em;
            font-weight: bold;
        }

        .probability-text.safe { color: #8f8; }
        .probability-text.risky { color: #fc8; }
        .probability-text.dangerous { color: #f88; }

        .foolproof-badge {
            display: inline-block;
            background: linear-gradient(135deg, #2a6a2a, #4a9a4a);
            color: #fff;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 10px;
            text-transform: uppercase;
        }

        /* Horizontal MCTS Results Layout */
        .mcts-results {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .mcts-recommendation {
            background: rgba(30, 60, 40, 0.9);
            border: 2px solid #4a8a4a;
            border-radius: 10px;
            padding: 15px;
        }

        .mcts-recommendation.risky {
            background: rgba(60, 50, 30, 0.9);
            border-color: #8a6a2a;
        }

        .mcts-recommendation.dangerous {
            background: rgba(60, 30, 30, 0.9);
            border-color: #8a3a3a;
        }

        .mcts-rec-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .mcts-rec-stats {
            color: #8f8;
            font-size: 0.95em;
        }

        .mcts-details {
            display: flex;
            gap: 12px;
        }

        .mcts-distribution {
            flex: 0 0 180px;
            background: rgba(30, 40, 60, 0.8);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #3a5a7a;
        }

        .mcts-distribution-title {
            color: #8af;
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .mcts-distribution-item {
            color: #aaa;
            font-size: 0.9em;
            padding: 2px 0;
        }

        .mcts-distribution-footer {
            color: #666;
            font-size: 0.75em;
            margin-top: 8px;
            border-top: 1px solid #3a5a7a;
            padding-top: 8px;
        }

        .mcts-comparison {
            flex: 1;
            background: rgba(30, 40, 60, 0.8);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid #3a5a7a;
            overflow: visible;
        }

        .mcts-comparison-title {
            color: #8af;
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .mcts-comparison table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .mcts-comparison th {
            color: #888;
            font-weight: normal;
            text-align: left;
            padding: 4px 8px;
            border-bottom: 1px solid #4a5a7a;
        }

        .mcts-comparison td {
            padding: 6px 8px;
            color: #ccc;
            border-bottom: 1px solid rgba(60, 80, 100, 0.3);
        }

        .mcts-comparison tr:first-child td {
            color: #8f8;
            font-weight: bold;
        }

        .info-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
            line-height: 14px;
            text-align: center;
            font-size: 10px;
            color: #888;
            border: 1px solid #666;
            border-radius: 50%;
            margin-left: 4px;
            cursor: help;
            position: relative;
        }

        .info-icon:hover {
            color: #aaa;
            border-color: #888;
        }

        .info-icon .info-tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a3a;
            color: #ccc;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #4a4a8a;
            font-size: 11px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 100;
            margin-bottom: 6px;
            transition: opacity 0.2s;
        }

        .info-icon:hover .info-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .history {
            background: rgba(20, 20, 50, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .history h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .history-item {
            padding: 8px;
            border-bottom: 1px solid rgba(60, 60, 100, 0.5);
            display: flex;
            justify-content: space-between;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-item .action {
            color: #aaa;
        }

        .history-item .mass-change {
            font-weight: bold;
        }

        .history-item .mass-change.negative {
            color: #f88;
        }

        .history-item .mass-change.recovery {
            color: #8f8;
        }

        .recovery-section {
            background: rgba(80, 40, 80, 0.3);
            border: 2px solid #8a4a8a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .recovery-section h3 {
            color: #faf;
            margin-bottom: 10px;
        }

        .recovery-section p {
            color: #caa;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .prediction {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .prediction h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
        }

        .prediction-item {
            background: rgba(40, 40, 70, 0.5);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .prediction-item .label {
            color: #888;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .prediction-item .value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .warning { color: #f88; }
        .safe { color: #8f8; }

        /* Fittings Section */
        .fittings-section {
            background: rgba(20, 30, 50, 0.9);
            border: 2px solid #3a5a7a;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .fittings-section h3 {
            color: #8cf;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .fittings-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }

        .fitting-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .fitting-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .ship-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #fc8;
        }

        .fit-name {
            font-size: 0.85em;
            color: #8ab;
        }

        .fitting-mass {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .mass-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .mass-cold {
            background: rgba(80, 150, 200, 0.2);
            border: 1px solid #4a8ab0;
            color: #8cf;
        }

        .mass-hot {
            background: rgba(200, 100, 80, 0.2);
            border: 1px solid #b06a4a;
            color: #f98;
        }

        .mass-ent {
            background: rgba(150, 100, 200, 0.2);
            border: 1px solid #8a6ab0;
            color: #c8f;
        }

        .fitting-text-container {
            position: relative;
        }

        .fitting-copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 6px 8px;
            font-size: 0.9em;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #4a6a8a;
            background: rgba(30, 50, 70, 0.9);
            color: #8ab;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .fitting-text-container:hover .fitting-copy-btn {
            opacity: 1;
        }

        .fitting-copy-btn:hover {
            background: rgba(50, 80, 110, 0.95);
            color: #adf;
            border-color: #6a8aaa;
        }

        .fitting-text {
            display: block;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            color: #9a9ac0;
            white-space: pre;
            margin: 0;
            line-height: 1.4;
            background: rgba(10, 20, 40, 0.8);
            border: 1px solid #2a4a6a;
            border-radius: 8px;
            padding: 12px;
            padding-top: 36px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.8em;
        }

        footer a {
            color: #88f;
        }

        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.3em;
            }

            .mass-remaining {
                font-size: 1.8em;
            }

            .sequence-grid {
                grid-template-columns: 1fr;
            }

            .mcts-details {
                flex-direction: column;
            }

            .mcts-distribution {
                flex: none;
            }

            .fittings-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div class="wormhole-bg" id="wormhole-bg"></div>

    <div class="container">
        <header>
            <h1>Wormhole Rolling Calculator</h1>
            <div class="system-info">
                by <a href="https://kristofferopsahl.com" target="_blank" style="color: #8cf; text-decoration: none;">Kristoffer Opsahl</a>
            </div>
        </header>

        <!-- 1. SETUP: First thing user does -->
        <div class="hole-setup-section">
            <div class="setup-header">
                <h3 class="section-header" style="margin-bottom: 0;">Hole Setup</h3>
                <button class="settings-toggle" onclick="toggleSetupSettings()">âš™ Settings</button>
            </div>

            <!-- Primary: Session Setup -->
            <div class="session-setup">
                <!-- Wormhole Type (per-session) -->
                <div class="setup-group">
                    <div class="setup-label">Wormhole Type</div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <select id="wormhole-select" onchange="onWormholeChange()"
                                style="padding: 10px; border-radius: 6px; border: 1px solid #4a8aaa;
                                       background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace; font-size: 1em; min-width: 200px;">
                            <option value="c247">C247 (C3 Static) - 2000M</option>
                            <option value="c391">C391 (C5/C6 Static) - 3000M</option>
                            <option value="h296">H296 (C5 Static) - 3000M</option>
                            <option value="c140">C140 (Lowsec) - 2000M</option>
                            <option value="d382">D382 (C2 Static) - 2000M</option>
                            <option value="x877">X877 (C4 Static) - 2000M</option>
                            <option value="custom">Custom...</option>
                        </select>
                        <div id="custom-wormhole" style="display: none; gap: 10px; align-items: center;">
                            <input type="number" id="custom-base-mass" placeholder="Base Mass (M)" min="100"
                                   style="width: 120px; padding: 8px; border-radius: 6px; border: 1px solid #4a8aaa;
                                          background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                            <span style="color: #888;">Â±</span>
                            <input type="number" id="custom-variance" placeholder="10" min="1" max="50" value="10"
                                   style="width: 60px; padding: 8px; border-radius: 6px; border: 1px solid #4a8aaa;
                                          background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                            <span style="color: #888;">%</span>
                            <button onclick="applyCustomWormhole()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #4a8a6a;
                                    background: linear-gradient(135deg, #2a6a4a, #3a8a6a); color: #adf; cursor: pointer;">Apply</button>
                        </div>
                    </div>
                </div>

                <!-- Visual State -->
                <div class="setup-group">
                    <div class="setup-label">Visual State</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <label style="flex: 1; min-width: 90px; cursor: pointer;">
                            <input type="radio" name="hole-state" value="fresh" checked style="display: none;">
                            <div class="state-option" id="state-fresh" style="padding: 10px 8px; border-radius: 8px; text-align: center;
                                        background: linear-gradient(135deg, #2a5a7a, #3a7a9a); border: 2px solid #4a9aba;
                                        transition: all 0.2s;">
                                <div style="font-weight: bold; color: #8df;">Fresh</div>
                                <div style="font-size: 0.7em; color: #aef; margin-top: 3px;">No untracked</div>
                            </div>
                        </label>
                        <label style="flex: 1; min-width: 90px; cursor: pointer;">
                            <input type="radio" name="hole-state" value="normal" style="display: none;">
                            <div class="state-option" id="state-normal" style="padding: 10px 8px; border-radius: 8px; text-align: center;
                                        background: linear-gradient(135deg, #2a6a4a, #3a8a6a); border: 2px solid #4a8a6a;
                                        transition: all 0.2s;">
                                <div style="font-weight: bold; color: #6fa;">Normal</div>
                                <div style="font-size: 0.7em; color: #8cf; margin-top: 3px;">May have passes</div>
                            </div>
                        </label>
                        <label style="flex: 1; min-width: 90px; cursor: pointer;">
                            <input type="radio" name="hole-state" value="reduced" style="display: none;">
                            <div class="state-option" id="state-reduced" style="padding: 10px 8px; border-radius: 8px; text-align: center;
                                        background: linear-gradient(135deg, #4a4a2a, #6a6a3a); border: 2px solid #6a6a4a;
                                        transition: all 0.2s;">
                                <div style="font-weight: bold; color: #fc8;">Reduced</div>
                                <div style="font-size: 0.7em; color: #ca8; margin-top: 3px;">10-50% left</div>
                            </div>
                        </label>
                        <label style="flex: 1; min-width: 90px; cursor: pointer;">
                            <input type="radio" name="hole-state" value="critical" style="display: none;">
                            <div class="state-option" id="state-critical" style="padding: 10px 8px; border-radius: 8px; text-align: center;
                                        background: linear-gradient(135deg, #5a3a3a, #7a4a4a); border: 2px solid #7a5a5a;
                                        transition: all 0.2s;">
                                <div style="font-weight: bold; color: #f88;">Critical</div>
                                <div style="font-size: 0.7em; color: #faa; margin-top: 3px;">&lt;10% left</div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Minimum Mass Passed -->
                <div class="setup-group">
                    <div class="setup-label">Minimum Mass Passed <span style="text-transform: none; color: #666;">(optional)</span></div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="setup-mass-input" placeholder="0" min="0"
                               style="width: 120px; padding: 10px; border-radius: 6px; border: 1px solid #4a8aaa;
                                      background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace; font-size: 1em;">
                        <span style="color: #888;">M</span>
                    </div>
                    <div id="wormhole-hint" style="color: #666; font-size: 0.75em; margin-top: 6px;">
                        C247 base mass: 2000M Â±10% (1800-2200M)
                    </div>
                </div>

                <!-- Primary CTA -->
                <button class="primary-cta" onclick="applyHoleSetup()">â–¶ Start Rolling Session</button>
            </div>

            <!-- Secondary: Collapsible Settings -->
            <div class="setup-settings" id="setup-settings">
                <div class="settings-header" onclick="toggleSetupSettings()">
                    <span>âš™ Settings:</span>
                    <span id="settings-summary">Battleship + HIC â€¢ 100k iterations</span>
                    <span class="expand-icon">â–¼</span>
                </div>
                <div class="settings-expanded" id="settings-expanded" style="display: none;">
                    <!-- Ships Config -->
                    <div class="setup-group">
                        <div class="setup-label">Ships</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span id="ships-summary" style="color: #aaa; font-size: 0.85em;"></span>
                        </div>
                        <div id="ship-config" style="margin-top: 10px;">
                            <div id="ship-list" style="display: flex; flex-direction: column; gap: 10px;"></div>
                            <div style="display: flex; gap: 10px; margin-top: 15px;">
                                <button onclick="addShip()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #4a8a6a;
                                        background: linear-gradient(135deg, #2a6a4a, #3a8a6a); color: #adf; cursor: pointer;">+ Add Ship</button>
                                <button onclick="resetShips()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #6a6a4a;
                                        background: linear-gradient(135deg, #4a4a3a, #5a5a4a); color: #ca8; cursor: pointer;">Reset to Defaults</button>
                            </div>
                        </div>
                    </div>

                    <!-- Analysis Iterations -->
                    <div class="setup-group">
                        <div class="setup-label">Analysis Iterations</div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="range" id="iteration-slider" min="10000" max="1000000" step="10000" value="100000"
                                   style="flex: 1; max-width: 200px; accent-color: #6af;">
                            <span id="iteration-value" style="font-size: 0.9em; color: #8af; min-width: 50px;">100k</span>
                        </div>
                    </div>

                    <!-- Trip Decay -->
                    <div class="setup-group">
                        <div class="setup-label">Trip Decay Factor</div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="range" id="decay-slider" min="0.80" max="0.99" step="0.01" value="0.95"
                                   style="flex: 1; max-width: 200px; accent-color: #6af;">
                            <span id="decay-value" style="font-size: 0.9em; color: #8af; min-width: 40px;">0.95</span>
                        </div>
                        <div style="color: #666; font-size: 0.7em; margin-top: 4px;">
                            Score = decay^trips (lower = prefer fewer trips)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 2. CURRENT STATE: Shows mass after setup -->
        <div class="mass-display">
            <h3 class="section-header">Current Mass Estimate</h3>
            <div class="mass-bar-container">
                <div class="mass-bar fresh" id="mass-bar" style="width: 100%"></div>
                <div class="variance-overlay" id="variance-overlay">
                    <span class="variance-label min" id="var-min-label"></span>
                    <span class="variance-label max" id="var-max-label" style="right: 0;"></span>
                </div>
            </div>
            <div class="mass-labels">
                <span>0%</span>
                <span>10% CRIT</span>
                <span>50% SHRINK</span>
                <span>100%</span>
            </div>
            <div class="mass-remaining" id="mass-remaining">2,000 M</div>
            <div class="variance-range" id="variance-range">
                Possible range: <span class="min" id="range-min">1800</span> - <span class="max" id="range-max">2200</span> M
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; align-items: center; margin-top: 10px;">
                <div class="status-badge status-fresh" id="status-badge">FRESH</div>
                <div class="status-badge" id="position-badge" style="background: rgba(74, 138, 74, 0.3); border: 2px solid #4a8a4a; color: #8f8;">HOME</div>
            </div>
        </div>

        <!-- 3. JUMP ACTIONS + HISTORY (combined panel) -->
        <div id="action-panel" class="control-section" style="margin-bottom: 20px; border-color: #4a8a6a; background: rgba(30, 60, 50, 0.4);">
            <h3 class="section-header" style="display: flex; justify-content: space-between; align-items: center;">
                <span>Record Jump</span>
                <span id="direction-label" style="font-size: 0.9em; color: #8f8;">â†’ Jumping OUT</span>
            </h3>
            <div class="action-history-container">
                <div class="jump-buttons-vertical">
                    <button class="btn-hot jump-btn" data-jump="BS_HOT" onclick="recordSingleJump('BS_HOT')">
                        BS Hot â†’ <span style="opacity: 0.7;">294M</span>
                    </button>
                    <button class="btn-cold jump-btn" data-jump="BS_COLD" onclick="recordSingleJump('BS_COLD')">
                        BS Cold â†’ <span style="opacity: 0.7;">194M</span>
                    </button>
                    <button class="btn-hot jump-btn" data-jump="HIC_HOT" onclick="recordSingleJump('HIC_HOT')" style="background: linear-gradient(135deg, #5a4a3a, #7a6a4a);">
                        HIC Hot â†’ <span style="opacity: 0.7;">132M</span>
                    </button>
                    <button class="btn-cold jump-btn" data-jump="HIC_COLD" onclick="recordSingleJump('HIC_COLD')" style="background: linear-gradient(135deg, #2a5a5a, #3a7a7a);">
                        HIC Cold â†’ <span style="opacity: 0.7;">32M</span>
                    </button>
                    <button class="btn-recovery jump-btn" data-jump="HIC_ENT" onclick="recordSingleJump('HIC_ENT')" style="background: linear-gradient(135deg, #4a2a5a, #6a3a7a);">
                        HIC Ent â†’ <span style="opacity: 0.7;">0.8M</span>
                    </button>
                </div>
                <div class="observation-buttons-vertical">
                    <button id="btn-normal" class="btn-normal obs-btn" onclick="recordNormalObservation()" disabled>
                        NORMAL
                    </button>
                    <button id="btn-shrunk" class="btn-shrunk obs-btn" onclick="holeJustShrunk()" disabled>
                        SHRUNK
                    </button>
                    <button id="btn-crit" class="btn-crit obs-btn" onclick="holeJustCrit()" disabled>
                        CRIT
                    </button>
                    <button id="btn-closed" class="btn-closed obs-btn" onclick="holeJustClosed()" disabled>
                        CLOSED
                    </button>
                    <div class="obs-spacer"></div>
                    <button class="btn-copy" onclick="copyEventLog()">Copy</button>
                    <button class="btn-undo" onclick="undoLast()">Undo</button>
                    <button class="btn-reset" onclick="resetCalculator()">Reset</button>
                </div>
                <div class="inline-history">
                    <div class="inline-history-header">
                        <h4>Event Log</h4>
                    </div>
                    <div class="history-list" id="history-list">
                        <div class="history-item">
                            <span class="action">No jumps recorded</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 5. ANALYSIS: MCTS Strategy recommendation -->
        <div class="monte-carlo">
            <h3 class="section-header">MCTS Strategy Analysis</h3>
            <div id="sim-status" style="color: #8af; margin-bottom: 10px;"></div>
            <div class="sequence-grid" id="sequence-grid">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- FITTINGS: Reference builds -->
        <div class="fittings-section">
            <h3 class="section-header">Ship Fittings</h3>
            <div class="fittings-container">
                <div class="fitting-card">
                    <div class="fitting-header">
                        <span class="ship-name">Apocalypse</span>
                        <span class="fit-name">WH Roller - Bulk</span>
                    </div>
                    <div class="fitting-mass">
                        <span class="mass-badge mass-cold">Cold: 194M</span>
                        <span class="mass-badge mass-hot">Hot: 294M</span>
                    </div>
                    <div class="fitting-text-container">
                        <button class="fitting-copy-btn" onclick="copyFitting('fit-apocalypse')" title="Copy to clipboard">&#128203;</button>
                        <pre class="fitting-text" id="fit-apocalypse">[Apocalypse, WH Roller - Bulk]
Damage Control II
Reinforced Bulkheads II
Reinforced Bulkheads II
Reinforced Bulkheads II
Reinforced Bulkheads II
Reinforced Bulkheads II
Reinforced Bulkheads II
Reinforced Bulkheads II

500MN Y-T8 Compact Microwarpdrive
Large Micro Jump Drive
Warp Scrambler II
Eutectic Compact Cap Recharger

Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Heavy Gremlin Compact Energy Neutralizer
Core Probe Launcher I

Large Higgs Anchor I
Large Transverse Bulkhead I
Large Transverse Bulkhead I

Hornet EC-300 x5

Mobile Depot x1
Prototype Cloaking Device I x1
Warp Core Stabilizer I x1
Inertial Stabilizers II x2
Core Scanner Probe I x16</pre>
                    </div>
                </div>
                <div class="fitting-card">
                    <div class="fitting-header">
                        <span class="ship-name">Devoter</span>
                        <span class="fit-name">WH Roller - Precision</span>
                    </div>
                    <div class="fitting-mass">
                        <span class="mass-badge mass-cold">Cold: 32M</span>
                        <span class="mass-badge mass-hot">Hot: 132M</span>
                        <span class="mass-badge mass-ent">Ent: 0.8M</span>
                    </div>
                    <div class="fitting-text-container">
                        <button class="fitting-copy-btn" onclick="copyFitting('fit-devoter')" title="Copy to clipboard">&#128203;</button>
                        <pre class="fitting-text" id="fit-devoter">[Devoter, WH Roller - Precision]
Nanofiber Internal Structure II
Nanofiber Internal Structure II
Nanofiber Internal Structure II
Inertial Stabilizers II
Capacitor Flux Coil II
Reactor Control Unit II
Co-Processor II

500MN Y-T8 Compact Microwarpdrive
Eutectic Compact Cap Recharger
100MN Y-S8 Compact Afterburner

Zero-Point Mass Entangler
Zero-Point Mass Entangler
Zero-Point Mass Entangler
Zero-Point Mass Entangler
Core Probe Launcher I, Sisters Core Scanner Probe
Prototype Cloaking Device I

Medium Higgs Anchor I
Medium Ancillary Current Router II

Hornet EC-300 x10

Mobile Depot x1
Warp Core Stabilizer I x1
Sisters Core Scanner Probe x8</pre>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            Wormhole Rolling Calculator<br>
            <a href="https://wiki.eveuniversity.org/Wormhole_attributes" target="_blank">EVE University Wormhole Guide</a>
        </footer>
    </div>

    <script>
        // Wormhole presets
        const WORMHOLE_PRESETS = {
            'c247': { id: 'c247', name: 'C247', desc: 'C3 Static', baseMass: 2000, variance: 0.10, maxJump: 375 },
            'c391': { id: 'c391', name: 'C391', desc: 'C5/C6 Static', baseMass: 3000, variance: 0.10, maxJump: 1350 },
            'h296': { id: 'h296', name: 'H296', desc: 'C5 Static', baseMass: 3000, variance: 0.10, maxJump: 1350 },
            'c140': { id: 'c140', name: 'C140', desc: 'Lowsec', baseMass: 2000, variance: 0.10, maxJump: 375 },
            'd382': { id: 'd382', name: 'D382', desc: 'C2 Static', baseMass: 2000, variance: 0.10, maxJump: 375 },
            'x877': { id: 'x877', name: 'X877', desc: 'C4 Static', baseMass: 2000, variance: 0.10, maxJump: 375 },
            'custom': { id: 'custom', name: 'Custom', desc: 'User-defined', baseMass: 2000, variance: 0.10, maxJump: 375 }
        };

        // Active wormhole (can be changed via selector)
        let activeWormhole = { ...WORMHOLE_PRESETS['c247'] };

        // Configuration
        const CONFIG = {
            // Thresholds
            shrinkThreshold: 0.50,
            critThreshold: 0.10,
            // MC settings
            simulations: 100000,  // Default - configurable via slider
            chunkSize: 25000,  // Iterations per chunk for async execution
            tripDecay: 0.95  // Exponential decay per trip (score = decay^trips)
        };

        // Derived config values (computed from activeWormhole and activeShips)
        function getBaseMass() { return activeWormhole.baseMass; }
        function getVariance() { return activeWormhole.variance; }
        function getMaxJumpMass() { return activeWormhole.maxJump; }

        // Async helper - yields to event loop for UI responsiveness
        function yieldToMain() {
            return new Promise(resolve => setTimeout(resolve, 0));
        }

        // Default ships (Apocalypse + Devoter with Higgs)
        const DEFAULT_SHIPS = [
            { id: 'bs', name: 'Battleship', cold: 194.2, hot: 294.2, ent: null },
            { id: 'hic', name: 'HIC', cold: 32.4, hot: 132.4, ent: 0.83 }
        ];

        // Active ships (editable by user)
        let activeShips = JSON.parse(JSON.stringify(DEFAULT_SHIPS));

        // Generate single jump actions from active ships
        function generateSingleJumps() {
            const jumps = {};
            for (const ship of activeShips) {
                const prefix = ship.id.toUpperCase();
                if (ship.hot) {
                    jumps[`${prefix}_HOT`] = { mass: ship.hot, label: `${ship.name} Hot`, ship: ship.id.toUpperCase() };
                }
                if (ship.cold) {
                    jumps[`${prefix}_COLD`] = { mass: ship.cold, label: `${ship.name} Cold`, ship: ship.id.toUpperCase() };
                }
                if (ship.ent) {
                    jumps[`${prefix}_ENT`] = { mass: ship.ent, label: `${ship.name} Ent`, ship: ship.id.toUpperCase() };
                }
            }
            return jumps;
        }

        // Generate round-trip actions from active ships
        function generateActions() {
            const actions = {};
            for (const ship of activeShips) {
                const prefix = ship.id.toUpperCase();
                const isHic = ship.ent !== null; // Has entangler = HIC-like behavior

                if (ship.hot) {
                    actions[`${prefix}_HOT`] = { out: ship.hot, back: ship.hot, label: `${ship.name} H/H`, isHic };
                }
                if (ship.cold) {
                    actions[`${prefix}_COLD`] = { out: ship.cold, back: ship.cold, label: `${ship.name} C/C`, isHic };
                }
                if (ship.cold && ship.hot) {
                    actions[`${prefix}_COLD_HOT`] = { out: ship.cold, back: ship.hot, label: `${ship.name} C/H`, isHic };
                }

                if (ship.ent) {
                    actions[`${prefix}_ENT`] = { out: ship.ent, back: ship.ent, label: `${ship.name} E/E`, isHic };
                    if (ship.hot) {
                        actions[`${prefix}_ENT_HOT`] = { out: ship.ent, back: ship.hot, label: `${ship.name} E/H`, isHic };
                    }
                }
            }
            return actions;
        }

        // Dynamic actions (regenerated when ships change)
        let SINGLE_JUMPS = generateSingleJumps();
        let ACTIONS = generateActions();

        // State (position is derived from history, not stored)
        let state = {
            massUsed: 0,
            history: [],
            hasUnknownMass: false,
            knownMinStart: getBaseMass() * (1 - getVariance()),
            knownMaxStart: getBaseMass() * (1 + getVariance()),
            awaitingObservation: false
        };

        let recommendedStrategy = null;
        let currentMctsRoot = null;  // Store MCTS tree for incremental updates
        let lastCompletedAction = null;  // Track last completed round-trip action
        let lastObservation = null;  // Track last observation (fresh/shrink/crit)

        // Derive position from jump history (odd = away, even = home)
        function getPosition() {
            const jumpCount = state.history.filter(h => h.type.startsWith('jump-')).length;
            return jumpCount % 2 === 0 ? 'home' : 'away';
        }

        // Get the ship type used for the last outbound jump (when away)
        function getShipUsedOut() {
            if (getPosition() === 'home') return null;
            const jumps = state.history.filter(h => h.type.startsWith('jump-'));
            const lastJump = jumps[jumps.length - 1];
            return lastJump?.ship || null;
        }

        // Get the last completed round-trip action key (for tree descent)
        function getLastCompletedActionKey() {
            const jumps = state.history.filter(h => h.type.startsWith('jump-'));
            if (jumps.length < 2) return null;

            // Get the last two jumps (should be out then back)
            const lastTwo = jumps.slice(-2);
            const outJump = lastTwo[0];
            const backJump = lastTwo[1];

            if (!outJump.type.includes('-out-') || !backJump.type.includes('-back-')) {
                return null;
            }

            const outMass = outJump.mass;
            const backMass = backJump.mass;

            // Find matching action
            for (const [key, act] of Object.entries(ACTIONS)) {
                if (act.out === outMass && act.back === backMass) {
                    return key;
                }
            }
            return null;
        }

        // Clear the MCTS tree (called on reset/recovery)
        function clearMctsTree() {
            currentMctsRoot = null;
            lastCompletedAction = null;
            lastObservation = null;
        }

        // ========== WORMHOLE CONFIGURATION ==========

        function onWormholeChange() {
            const select = document.getElementById('wormhole-select');
            const customDiv = document.getElementById('custom-wormhole');
            const whId = select.value;

            if (whId === 'custom') {
                customDiv.style.display = 'flex';
                return;
            }

            customDiv.style.display = 'none';
            activeWormhole = { ...WORMHOLE_PRESETS[whId] };
            applyWormholeConfig();
        }

        function applyCustomWormhole() {
            const baseMass = parseFloat(document.getElementById('custom-base-mass').value) || 2000;
            const variance = (parseFloat(document.getElementById('custom-variance').value) || 10) / 100;

            activeWormhole = {
                id: 'custom',
                name: 'Custom',
                desc: `${baseMass}M`,
                baseMass: baseMass,
                variance: variance,
                maxJump: baseMass * 0.3  // Reasonable default
            };
            applyWormholeConfig();
        }

        function applyWormholeConfig() {
            // Update state bounds
            state.knownMinStart = getBaseMass() * (1 - getVariance());
            state.knownMaxStart = getBaseMass() * (1 + getVariance());

            // Update UI
            updateWormholeDisplay();
            updateSpecCards();
            clearMctsTree();
            saveConfig();
            resetState();  // Reset mass tracking for new wormhole
        }

        function updateWormholeDisplay() {
            const wh = activeWormhole;
            const minMass = Math.round(wh.baseMass * (1 - wh.variance));
            const maxMass = Math.round(wh.baseMass * (1 + wh.variance));
            const variancePct = Math.round(wh.variance * 100);

            // Update hint text
            const hint = document.getElementById('wormhole-hint');
            if (hint) {
                hint.textContent = `${wh.name}: ${minMass}-${maxMass}M total. Untracked mass (prop mods, hostiles) may add more.`;
            }
        }

        // ========== SHIP CONFIGURATION ==========

        function toggleShipConfig() {
            const config = document.getElementById('ship-config');
            const btn = document.getElementById('ship-config-toggle');
            if (config.style.display === 'none') {
                config.style.display = 'block';
                btn.textContent = 'Hide';
                renderShipList();
            } else {
                config.style.display = 'none';
                btn.textContent = 'Configure';
            }
        }

        function renderShipList() {
            const container = document.getElementById('ship-list');
            container.innerHTML = activeShips.map((ship, idx) => `
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <input type="text" value="${ship.name}" placeholder="Name" data-idx="${idx}" data-field="name"
                           onchange="updateShipField(${idx}, 'name', this.value)"
                           style="width: 100px; padding: 8px; border-radius: 4px; border: 1px solid #4a6a8a;
                                  background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="color: #888; font-size: 0.85em;">Cold:</span>
                        <input type="number" value="${ship.cold}" step="0.1" data-idx="${idx}" data-field="cold"
                               onchange="updateShipField(${idx}, 'cold', parseFloat(this.value))"
                               style="width: 90px; padding: 8px; border-radius: 4px; border: 1px solid #4a6a8a;
                                      background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="color: #888; font-size: 0.85em;">Hot:</span>
                        <input type="number" value="${ship.hot}" step="0.1" data-idx="${idx}" data-field="hot"
                               onchange="updateShipField(${idx}, 'hot', parseFloat(this.value))"
                               style="width: 90px; padding: 8px; border-radius: 4px; border: 1px solid #4a6a8a;
                                      background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="color: #888; font-size: 0.85em;">Ent:</span>
                        <input type="number" value="${ship.ent !== null ? ship.ent : ''}" step="0.01" placeholder="-"
                               data-idx="${idx}" data-field="ent"
                               onchange="updateShipField(${idx}, 'ent', this.value ? parseFloat(this.value) : null)"
                               style="width: 80px; padding: 8px; border-radius: 4px; border: 1px solid #4a6a8a;
                                      background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace;">
                    </div>
                    <button onclick="removeShip(${idx})" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #8a4a4a;
                            background: rgba(80, 40, 40, 0.6); color: #f88; cursor: pointer; font-size: 1.1em;">Ã—</button>
                </div>
            `).join('');
        }

        function updateShipField(idx, field, value) {
            activeShips[idx][field] = value;
            // Update ID based on name if name changes
            if (field === 'name') {
                activeShips[idx].id = value.toLowerCase().replace(/[^a-z0-9]/g, '');
            }
            applyShipConfig();
        }

        function addShip() {
            const newId = 'ship' + (activeShips.length + 1);
            activeShips.push({ id: newId, name: 'New Ship', cold: 100, hot: 200, ent: null });
            renderShipList();
            applyShipConfig();
        }

        function removeShip(idx) {
            if (activeShips.length <= 1) {
                alert('You need at least one ship!');
                return;
            }
            activeShips.splice(idx, 1);
            renderShipList();
            applyShipConfig();
        }

        function resetShips() {
            activeShips = JSON.parse(JSON.stringify(DEFAULT_SHIPS));
            renderShipList();
            applyShipConfig();
        }

        function applyShipConfig() {
            // Regenerate actions
            SINGLE_JUMPS = generateSingleJumps();
            ACTIONS = generateActions();

            // Update UI
            renderJumpButtons();
            updateShipsSummary();
            updateSettingsSummary();
            updateSpecCards();
            clearMctsTree();
            saveConfig();
            runStrategyAnalysis();
        }

        function updateShipsSummary() {
            const summary = document.getElementById('ships-summary');
            if (summary) {
                summary.textContent = activeShips.map(s => s.name).join(', ');
            }
        }

        function renderJumpButtons() {
            const container = document.querySelector('.jump-buttons-vertical');
            if (!container) return;

            container.innerHTML = '';
            for (const [key, jump] of Object.entries(SINGLE_JUMPS)) {
                const btn = document.createElement('button');
                const isHot = key.includes('_HOT');
                const isEnt = key.includes('_ENT');
                const ship = activeShips.find(s => s.id.toUpperCase() === jump.ship);
                const isHic = ship && ship.ent !== null;

                let bgStyle, borderColor;
                if (isEnt) {
                    bgStyle = 'linear-gradient(135deg, #4a2a5a, #6a3a7a)';
                    borderColor = '#8a4a9a';
                } else if (isHic) {
                    bgStyle = isHot
                        ? 'linear-gradient(135deg, #5a4a3a, #7a6a4a)'
                        : 'linear-gradient(135deg, #3a4a4a, #4a6a6a)';
                    borderColor = isHot ? '#9a8a5a' : '#5a7a7a';
                } else {
                    bgStyle = isHot
                        ? 'linear-gradient(135deg, #5a3a2a, #7a5a3a)'
                        : 'linear-gradient(135deg, #2a4a5a, #3a6a7a)';
                    borderColor = isHot ? '#9a6a4a' : '#4a7a9a';
                }

                btn.className = 'jump-btn';
                btn.dataset.jump = key;
                btn.onclick = () => recordSingleJump(key);
                btn.style.background = bgStyle;
                btn.style.border = `2px solid ${borderColor}`;
                btn.style.color = '#fff';
                btn.innerHTML = `${jump.label} â†’ <span style="opacity: 0.7;">${Math.round(jump.mass)}M</span>`;
                container.appendChild(btn);
            }
        }

        function updateSpecCards() {
            updateWormholeDisplay();
        }

        // ========== CONFIGURATION PERSISTENCE ==========

        function saveConfig() {
            localStorage.setItem('wh-calc-config', JSON.stringify({
                wormhole: activeWormhole,
                ships: activeShips
            }));
        }

        function loadConfig() {
            const saved = localStorage.getItem('wh-calc-config');
            if (saved) {
                try {
                    const config = JSON.parse(saved);
                    if (config.wormhole) {
                        activeWormhole = config.wormhole;
                        // Update selector to match
                        const select = document.getElementById('wormhole-select');
                        if (select) {
                            select.value = activeWormhole.id || 'c247';
                            if (activeWormhole.id === 'custom') {
                                document.getElementById('custom-wormhole').style.display = 'flex';
                                document.getElementById('custom-base-mass').value = activeWormhole.baseMass;
                                document.getElementById('custom-variance').value = Math.round(activeWormhole.variance * 100);
                            }
                        }
                    }
                    if (config.ships && config.ships.length > 0) {
                        activeShips = config.ships;
                    }
                } catch (e) {
                    console.error('Failed to load config:', e);
                }
            }

            // Regenerate actions from loaded config
            SINGLE_JUMPS = generateSingleJumps();
            ACTIONS = generateActions();
        }

        function init() {
            loadConfig();
            loadState();
            createStarfield();
            createWormholeEffect();
            initStateSelection();
            initIterationSlider();
            initDecaySlider();
            // Initialize dynamic UI components
            updateWormholeDisplay();
            updateShipsSummary();
            updateSettingsSummary();
            updateSpecCards();
            renderJumpButtons();
            // Run analysis asynchronously to not block UI
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 100);
        }

        function initIterationSlider() {
            const slider = document.getElementById('iteration-slider');
            const valueDisplay = document.getElementById('iteration-value');
            if (!slider || !valueDisplay) return;

            // Load saved value from localStorage (with migration from old key)
            let savedIterations = localStorage.getItem('wh-calc-iterations');
            if (!savedIterations) {
                const oldIterations = localStorage.getItem('eedvr-wh-calc-iterations');
                if (oldIterations) {
                    savedIterations = oldIterations;
                    localStorage.setItem('wh-calc-iterations', oldIterations);
                    localStorage.removeItem('eedvr-wh-calc-iterations');
                }
            }
            if (savedIterations) {
                const value = parseInt(savedIterations);
                if (value >= 10000 && value <= 1000000) {
                    slider.value = value;
                    CONFIG.simulations = value;
                    valueDisplay.textContent = value >= 1000000 ? '1M' : Math.round(value / 1000) + 'k';
                }
            }

            slider.addEventListener('input', () => {
                const value = parseInt(slider.value);
                CONFIG.simulations = value;
                valueDisplay.textContent = value >= 1000000 ? '1M' : Math.round(value / 1000) + 'k';
                localStorage.setItem('wh-calc-iterations', value);
                updateSettingsSummary();
            });

            slider.addEventListener('change', () => {
                // Re-run analysis with new iteration count
                runStrategyAnalysis();
                updateSettingsSummary();
            });
        }

        function initDecaySlider() {
            const slider = document.getElementById('decay-slider');
            const valueDisplay = document.getElementById('decay-value');
            if (!slider || !valueDisplay) return;

            // Load saved value from localStorage
            const savedDecay = localStorage.getItem('wh-calc-decay');
            if (savedDecay) {
                const value = parseFloat(savedDecay);
                if (value >= 0.80 && value <= 0.99) {
                    slider.value = value;
                    CONFIG.tripDecay = value;
                    valueDisplay.textContent = value.toFixed(2);
                }
            }

            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                CONFIG.tripDecay = value;
                valueDisplay.textContent = value.toFixed(2);
                localStorage.setItem('wh-calc-decay', value);
            });

            slider.addEventListener('change', () => {
                // Re-run analysis with new decay value
                runStrategyAnalysis();
            });
        }

        function toggleSetupSettings() {
            const expanded = document.getElementById('settings-expanded');
            const icon = document.querySelector('.expand-icon');
            if (!expanded) return;

            if (expanded.style.display === 'none') {
                expanded.style.display = 'flex';
                if (icon) icon.style.transform = 'rotate(180deg)';
                renderShipList();  // Make sure ship list is rendered
            } else {
                expanded.style.display = 'none';
                if (icon) icon.style.transform = 'rotate(0deg)';
            }
        }

        function updateSettingsSummary() {
            const summaryEl = document.getElementById('settings-summary');
            if (!summaryEl) return;

            const ships = activeShips.map(s => s.name).join(' + ');
            const iterations = CONFIG.simulations >= 1000000
                ? '1M'
                : Math.round(CONFIG.simulations / 1000) + 'k';

            summaryEl.textContent = `${ships} â€¢ ${iterations} iterations`;
        }

        function createStarfield() {
            const container = document.getElementById('stars');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createWormholeEffect() {
            const container = document.getElementById('wormhole-bg');
            const colors = ['#4af', '#84f', '#a4f', '#f4a', '#fa4'];
            for (let i = 0; i < 8; i++) {
                const ring = document.createElement('div');
                ring.className = 'wormhole-ring';
                const size = 100 + i * 80;
                ring.style.width = size + 'px';
                ring.style.height = size + 'px';
                ring.style.left = (400 - size/2) + 'px';
                ring.style.top = (400 - size/2) + 'px';
                ring.style.borderColor = colors[i % colors.length];
                ring.style.animationDelay = (i * 0.5) + 's';
                container.appendChild(ring);
            }
        }

        // MCTS Thresholds (remaining mass thresholds for visual state)
        function getShrinkThreshold() { return getBaseMass() * CONFIG.shrinkThreshold; }
        function getCritThreshold() { return getBaseMass() * CONFIG.critThreshold; }

        // ============================================================
        // MCTS Implementation - Proper tree search with backpropagation
        // ============================================================

        // POMCTS: Partially Observable Monte Carlo Tree Search
        // Nodes branch on (action, observation) pairs to properly handle belief updates

        class POMCTSNode {
            constructor(totalBelief, massUsed, parent = null, incomingAction = null, incomingActionKey = null, incomingObservation = null, depth = 0) {
                this.totalBelief = { min: totalBelief.min, max: totalBelief.max };  // Belief about TOTAL wormhole mass
                this.massUsed = massUsed;  // Cumulative mass used to reach this node
                this.parent = parent;
                this.incomingAction = incomingAction;
                this.incomingActionKey = incomingActionKey;
                this.incomingObservation = incomingObservation;  // 'fresh', 'shrink', 'crit', or null for root

                // Children indexed by action key, then observation
                // this.children[actionKey][observation] = POMCTSNode
                this.children = {};

                this.visits = 0;
                this.wins = 0;  // Weighted score (sum of decay^trips)
                this.successes = 0;  // Raw success count
                this.depth = depth;  // Number of round trips
                this.terminalTrips = {};
            }

            // Compute remaining mass belief from total belief
            getRemainingBelief() {
                return {
                    min: Math.max(0, this.totalBelief.min - this.massUsed),
                    max: Math.max(0, this.totalBelief.max - this.massUsed)
                };
            }

            isTerminal() {
                const remaining = this.getRemainingBelief();
                return remaining.max <= 0;
            }

            getValidActions() {
                const remaining = this.getRemainingBelief();
                // Only filter out actions that can't possibly survive outbound
                return Object.entries(ACTIONS).filter(([key, act]) => {
                    return remaining.max > act.out;
                });
            }

            // Get or create child for (action, observation) pair
            getChild(actionKey, observation) {
                if (this.children[actionKey] && this.children[actionKey][observation]) {
                    return this.children[actionKey][observation];
                }
                return null;
            }

            setChild(actionKey, observation, child) {
                if (!this.children[actionKey]) {
                    this.children[actionKey] = {};
                }
                this.children[actionKey][observation] = child;
            }

            hasChild(actionKey, observation) {
                return this.children[actionKey] && this.children[actionKey][observation];
            }

            // Aggregate stats for an action across all observation branches
            getActionStats(actionKey) {
                const branches = this.children[actionKey];
                if (!branches) return { visits: 0, wins: 0, successes: 0 };

                let totalVisits = 0;
                let totalWins = 0;
                let totalSuccesses = 0;
                for (const obs in branches) {
                    totalVisits += branches[obs].visits;
                    totalWins += branches[obs].wins;
                    totalSuccesses += branches[obs].successes;
                }
                return { visits: totalVisits, wins: totalWins, successes: totalSuccesses };
            }

            // UCB1 for an action (aggregated across observation branches)
            ucb1ForAction(actionKey, C = 1.414) {
                const stats = this.getActionStats(actionKey);
                if (stats.visits === 0) return Infinity;
                const exploitation = stats.wins / stats.visits;
                const exploration = C * Math.sqrt(Math.log(this.visits) / stats.visits);
                return exploitation + exploration;
            }

            // Get all action keys that have any children
            getExploredActions() {
                return Object.keys(this.children);
            }
        }

        // Compute observation given true mass and mass used
        function computeObservation(trueMass, massUsed) {
            const remaining = trueMass - massUsed;
            const remainingPct = remaining / trueMass;

            if (remaining <= 0) return 'collapsed';
            if (remainingPct <= CONFIG.critThreshold) return 'crit';
            if (remainingPct <= CONFIG.shrinkThreshold) return 'shrink';
            return 'fresh';
        }

        // Update total mass belief based on observation
        function updateTotalBelief(currentTotalBelief, massUsed, observation) {
            let newMin = currentTotalBelief.min;
            let newMax = currentTotalBelief.max;

            if (observation === 'fresh') {
                // Remaining > 50% of total â†’ total > 2 * massUsed
                newMin = Math.max(newMin, 2 * massUsed + 1);
            } else if (observation === 'shrink') {
                // 10% < remaining â‰¤ 50% â†’ massUsed/0.9 < total â‰¤ 2*massUsed
                newMin = Math.max(newMin, massUsed / 0.9 + 1);
                newMax = Math.min(newMax, 2 * massUsed);
            } else if (observation === 'crit') {
                // Remaining â‰¤ 10% â†’ total â‰¤ massUsed/0.9
                newMax = Math.min(newMax, massUsed / 0.9);
            }
            // 'collapsed' means we're done - no belief update needed

            return { min: newMin, max: newMax };
        }

        // Run a single MCTS iteration (extracted for reuse)
        function runSingleIteration(root, startMin, startMax, initialMassUsed) {
            const trueMass = startMin + Math.random() * (startMax - startMin);
            let currentMassUsed = initialMassUsed;
            let remaining = trueMass - currentMassUsed;

            const path = [root];
            let node = root;
            let rolledOut = false;

            // 1. SELECTION + EXPANSION
            while (!node.isTerminal() && !rolledOut) {
                const validActions = node.getValidActions();
                if (validActions.length === 0) break;

                let selectedActionKey = null;
                let selectedAction = null;
                let needsExpansion = false;

                for (const [key, act] of validActions) {
                    if (remaining <= act.out) continue;
                    const newMassUsed = currentMassUsed + act.out + act.back;
                    const observation = computeObservation(trueMass, newMassUsed);

                    if (!node.hasChild(key, observation)) {
                        selectedActionKey = key;
                        selectedAction = act;
                        needsExpansion = true;
                        break;
                    }
                }

                // Use UCB1 for selection
                if (!needsExpansion && !selectedActionKey) {
                    let bestUCB = -Infinity;
                    for (const [key, act] of validActions) {
                        if (remaining <= act.out) continue;
                        const ucb = node.ucb1ForAction(key);
                        if (ucb > bestUCB) {
                            bestUCB = ucb;
                            selectedActionKey = key;
                            selectedAction = act;
                        }
                    }
                }

                if (!selectedAction) {
                    rolledOut = true;
                    break;
                }

                if (remaining <= selectedAction.out) {
                    rolledOut = true;
                    break;
                }

                const newMassUsed = currentMassUsed + selectedAction.out + selectedAction.back;
                remaining = trueMass - newMassUsed;
                const observation = computeObservation(trueMass, newMassUsed);

                let child = node.getChild(selectedActionKey, observation);
                if (!child) {
                    const newTotalBelief = updateTotalBelief(node.totalBelief, newMassUsed, observation);
                    child = new POMCTSNode(
                        newTotalBelief,
                        newMassUsed,
                        node,
                        selectedAction,
                        selectedActionKey,
                        observation,
                        node.depth + 1
                    );
                    node.setChild(selectedActionKey, observation, child);
                }

                currentMassUsed = newMassUsed;
                node = child;
                path.push(node);

                // Exit if hole collapsed (remaining <= 0 for this sample)
                if (remaining <= 0) break;

                if (needsExpansion) break;
            }

            // 2. SIMULATION
            let trips = node.depth;
            let simMassUsed = currentMassUsed;

            if (!rolledOut && remaining > 0) {
                while (remaining > 0 && trips < 20) {
                    const validActions = Object.entries(ACTIONS).filter(([k, a]) => remaining > a.out);
                    if (validActions.length === 0) {
                        rolledOut = true;
                        break;
                    }
                    validActions.sort((a, b) => (b[1].out + b[1].back) - (a[1].out + a[1].back));
                    const [key, act] = validActions[0];
                    trips++;
                    simMassUsed += act.out + act.back;
                    remaining = trueMass - simMassUsed;
                }
            }

            // 3. BACKPROPAGATION
            const success = !rolledOut && remaining <= 0;
            const score = success ? Math.pow(CONFIG.tripDecay, trips) : 0;
            for (const n of path) {
                n.visits++;
                if (success) {
                    n.wins += score;
                    n.successes++;
                    n.terminalTrips[trips] = (n.terminalTrips[trips] || 0) + 1;
                }
            }
        }

        // Main POMCTS algorithm - async chunked for UI responsiveness
        async function runPOMCTS(startMin, startMax, initialMassUsed, numIterations = CONFIG.simulations, onProgress = null) {
            const rootTotalBelief = { min: startMin, max: startMax };
            const root = new POMCTSNode(rootTotalBelief, initialMassUsed);
            const chunkSize = CONFIG.chunkSize;

            for (let i = 0; i < numIterations; i++) {
                runSingleIteration(root, startMin, startMax, initialMassUsed);

                // Yield to event loop every chunkSize iterations
                if (i > 0 && i % chunkSize === 0) {
                    if (onProgress) onProgress(i, numIterations);
                    await yieldToMain();
                }
            }

            return root;
        }

        // Alias for backward compatibility
        async function runMCTS(rootBelief, startMin, startMax, massUsed, numIterations = CONFIG.simulations, onProgress = null) {
            return runPOMCTS(startMin, startMax, massUsed, numIterations, onProgress);
        }

        // Extract best action from POMCTS tree (most visited action, aggregated across observations)
        function getMCTSBestAction(root) {
            const actionKeys = Object.keys(root.children);
            if (actionKeys.length === 0) return null;

            let bestKey = null;
            let bestStats = { visits: 0, wins: 0 };
            let bestAction = null;

            for (const key of actionKeys) {
                const stats = root.getActionStats(key);
                if (stats.visits > bestStats.visits) {
                    bestStats = stats;
                    bestKey = key;
                    // Get action from any observation branch
                    const observations = root.children[key];
                    const firstObs = Object.keys(observations)[0];
                    bestAction = observations[firstObs].incomingAction;
                }
            }

            if (!bestAction) return null;

            const remainingBelief = root.getRemainingBelief();
            return {
                key: bestKey,
                action: bestAction,
                visits: bestStats.visits,
                wins: bestStats.wins,
                successRate: bestStats.visits > 0 ? bestStats.wins / bestStats.visits : 0,
                guaranteedSafe: remainingBelief.min > bestAction.out
            };
        }

        // Extract all action results from POMCTS tree (aggregated across observations)
        function getMCTSActionResults(root) {
            const results = [];
            const remainingBelief = root.getRemainingBelief();

            for (const actionKey of Object.keys(root.children)) {
                const observations = root.children[actionKey];

                // Aggregate stats across all observation branches
                let totalVisits = 0;
                let totalWins = 0;  // Weighted score (sum of decay^trips)
                let totalSuccesses = 0;  // Raw success count
                let totalTrips = 0;
                let action = null;

                for (const obs of Object.keys(observations)) {
                    const child = observations[obs];
                    totalVisits += child.visits;
                    totalWins += child.wins;
                    totalSuccesses += child.successes;
                    action = child.incomingAction;

                    // Aggregate terminal trips for avgSteps calculation
                    for (const [trips, count] of Object.entries(child.terminalTrips)) {
                        totalTrips += parseInt(trips) * count;
                    }
                }

                if (!action) continue;

                const avgSteps = totalSuccesses > 0 ? totalTrips / totalSuccesses : 0;

                // Calculate probability of safe outbound jump
                // MCTS only explores actions when trueMass > act.out, so observed rate
                // is biased towards safe scenarios. Adjust for full belief distribution.
                const beliefRange = remainingBelief.max - remainingBelief.min;
                let pSafeOutbound = 1.0;
                if (beliefRange > 0 && action.out > remainingBelief.min) {
                    const safeRange = Math.max(0, remainingBelief.max - action.out);
                    pSafeOutbound = safeRange / beliefRange;
                }

                // Raw success rate (probability of completing without rollout)
                const observedSuccessRate = totalVisits > 0 ? totalSuccesses / totalVisits : 0;
                const successRate = pSafeOutbound * observedSuccessRate;

                // Strategy score (weighted by trip count)
                const observedScore = totalVisits > 0 ? totalWins / totalVisits : 0;
                const strategyScore = pSafeOutbound * observedScore;

                results.push({
                    key: actionKey,
                    act: action,
                    visits: totalVisits,
                    wins: totalWins,
                    successes: totalSuccesses,
                    total: totalVisits,
                    successRate,
                    strategyScore,
                    avgSteps,
                    mass: action.out + action.back,
                    guaranteedSafe: remainingBelief.min > action.out
                });
            }
            // Sort by strategy score (higher = better), then visits as tiebreaker
            results.sort((a, b) => {
                const scoreDiff = b.strategyScore - a.strategyScore;
                if (Math.abs(scoreDiff) > 0.01) return scoreDiff;
                return b.visits - a.visits;
            });
            return results;
        }

        // Extract trip distribution from POMCTS tree root
        function getMCTSTripDistribution(root, actionKey = null) {
            // If actionKey provided, get distribution for that specific action
            if (actionKey && root.children[actionKey]) {
                const observations = root.children[actionKey];
                let totalSuccesses = 0;
                const tripCounts = {};

                for (const obs of Object.keys(observations)) {
                    const child = observations[obs];
                    for (const [trips, count] of Object.entries(child.terminalTrips)) {
                        tripCounts[trips] = (tripCounts[trips] || 0) + count;
                        totalSuccesses += count;
                    }
                }

                if (totalSuccesses === 0) return [];

                const distribution = [];
                for (const [trips, count] of Object.entries(tripCounts)) {
                    const pct = count / totalSuccesses;
                    if (pct >= 0.01) {
                        distribution.push({ trips: parseInt(trips), pct });
                    }
                }
                return distribution.sort((a, b) => a.trips - b.trips);
            }

            // Otherwise return overall distribution
            const totalWins = root.wins;
            if (totalWins === 0) return [];

            const distribution = [];
            for (const [trips, count] of Object.entries(root.terminalTrips)) {
                const pct = count / totalWins;
                if (pct >= 0.01) {  // Only show >=1%
                    distribution.push({ trips: parseInt(trips), pct });
                }
            }
            return distribution.sort((a, b) => a.trips - b.trips);
        }

        // Extract recommended sequence by following most-visited path
        function getMCTSSequence(root) {
            const sequence = [];
            let node = root;

            while (Object.keys(node.children).length > 0) {
                // Find best action (most visited)
                let bestKey = null;
                let bestVisits = 0;

                for (const actionKey of Object.keys(node.children)) {
                    const stats = node.getActionStats(actionKey);
                    if (stats.visits > bestVisits) {
                        bestVisits = stats.visits;
                        bestKey = actionKey;
                    }
                }

                if (!bestKey || bestVisits === 0) break;
                sequence.push(bestKey);

                // Follow the most-visited observation branch for this action
                const observations = node.children[bestKey];
                let bestChild = null;
                let bestChildVisits = 0;
                for (const obs of Object.keys(observations)) {
                    if (observations[obs].visits > bestChildVisits) {
                        bestChildVisits = observations[obs].visits;
                        bestChild = observations[obs];
                    }
                }

                if (!bestChild) break;
                node = bestChild;
            }

            return sequence;
        }



        // Main MCTS analysis function - async for UI responsiveness
        async function runStrategyAnalysis() {
            const statusEl = document.getElementById('sim-status');
            statusEl.textContent = 'Running MCTS analysis...';

            let startMin = state.knownMinStart;
            let startMax = state.knownMaxStart;
            const massUsed = state.massUsed;

            // Narrow bounds based on required observation (streamline MCTS search space)
            const requiredObs = getRequiredObservation();
            if (requiredObs === 'crit') {
                // Remaining â‰¤ 10% â†’ total â‰¤ massUsed/0.9
                startMax = Math.min(startMax, massUsed / 0.9);
            } else if (requiredObs === 'shrink') {
                // 10% < remaining â‰¤ 50% â†’ massUsed/0.9 < total â‰¤ 2*massUsed
                startMin = Math.max(startMin, massUsed / 0.9 + 1);
                startMax = Math.min(startMax, 2 * massUsed);
            }
            const minRemaining = startMin - massUsed;
            const maxRemaining = startMax - massUsed;

            const belief = { min: minRemaining, max: maxRemaining };
            const position = getPosition();
            const shipUsedOut = getShipUsedOut();

            // Progress callback to update UI
            const updateProgress = (current, total) => {
                const pct = Math.round((current / total) * 100);
                statusEl.textContent = `Running MCTS... ${pct}% (${current.toLocaleString()}/${total.toLocaleString()})`;
            };

            // If we're AWAY, compute return options AND outbound analysis for when we get back
            if (position === 'away') {
                const returnResults = evaluateReturnOptions(belief, startMin, startMax, massUsed, shipUsedOut);

                // Also run MCTS to show what to do when we get back
                statusEl.textContent = `Running MCTS analysis...`;
                const mctsRoot = await runMCTS(belief, startMin, startMax, massUsed, CONFIG.simulations, updateProgress);
                const outboundResults = getMCTSActionResults(mctsRoot);
                const topActionKey = outboundResults.length > 0 ? outboundResults[0].key : null;
                const tripDist = getMCTSTripDistribution(mctsRoot, topActionKey);

                recommendedStrategy = {
                    sequence: [],
                    returnResults: returnResults,
                    actionResults: outboundResults,
                    tripDistribution: tripDist,
                    nextAction: returnResults.length > 0 ? returnResults[0] : null,
                    minRemaining,
                    maxRemaining,
                    belief,
                    isReturn: true,
                    shipUsedOut: shipUsedOut,
                    mctsIterations: mctsRoot.visits
                };
                statusEl.textContent = `You are AWAY with ${shipUsedOut}. Showing return options + analysis.`;
                displayStrategyAnalysis();
                return;
            }

            // Normal case: we're HOME, try to reuse existing tree
            let mctsRoot = null;
            let reusedTree = false;
            const additionalIterations = Math.floor(CONFIG.simulations / 10);  // 10% additional iterations

            // Try to descend existing tree if we have a completed action + observation
            if (currentMctsRoot && lastCompletedAction && lastObservation) {
                const childNode = currentMctsRoot.getChild(lastCompletedAction, lastObservation);
                if (childNode) {
                    // Descend to child and run additional iterations
                    mctsRoot = childNode;
                    mctsRoot.parent = null;  // Detach from parent
                    reusedTree = true;

                    // Run additional iterations on the subtree
                    statusEl.textContent = `Running ${additionalIterations.toLocaleString()} additional iterations...`;
                    await runAdditionalIterations(mctsRoot, startMin, startMax, massUsed, additionalIterations, updateProgress);
                }
            }

            // If we couldn't reuse, build fresh tree
            if (!mctsRoot) {
                mctsRoot = await runMCTS(belief, startMin, startMax, massUsed, CONFIG.simulations, updateProgress);
            }

            // Store for future reuse
            currentMctsRoot = mctsRoot;
            lastCompletedAction = null;  // Reset until next round trip
            lastObservation = null;

            // Extract results from tree
            const actionResults = getMCTSActionResults(mctsRoot);

            // Build recommended sequence from tree (follows most-visited path)
            const sequence = getMCTSSequence(mctsRoot);

            // Trip distribution for top strategy
            const topActionKey = actionResults.length > 0 ? actionResults[0].key : null;
            const tripDistribution = getMCTSTripDistribution(mctsRoot, topActionKey);

            // Get the best next action
            const nextAction = actionResults.length > 0 ? actionResults[0] : null;

            recommendedStrategy = {
                sequence,
                tripDistribution,
                actionResults,
                nextAction,
                minRemaining,
                maxRemaining,
                belief,
                isReturn: false,
                mctsIterations: mctsRoot.visits
            };

            const reuseNote = reusedTree ? ' (reused tree)' : '';
            statusEl.textContent = `MCTS: ${mctsRoot.visits.toLocaleString()} iterations across ${actionResults.length} actions${reuseNote}`;

            displayStrategyAnalysis();
        }

        // Run additional MCTS iterations on an existing subtree - async chunked
        async function runAdditionalIterations(root, startMin, startMax, initialMassUsed, numIterations, onProgress = null) {
            const chunkSize = CONFIG.chunkSize;

            for (let i = 0; i < numIterations; i++) {
                runSingleIteration(root, startMin, startMax, initialMassUsed);

                if (i > 0 && i % chunkSize === 0) {
                    if (onProgress) onProgress(i, numIterations);
                    await yieldToMain();
                }
            }
        }

        // Evaluate return options when we're away
        function evaluateReturnOptions(belief, startMin, startMax, massUsed, shipUsedOut) {
            const results = [];

            // Only consider return modes for the ship we went out with
            const returnModes = Object.entries(SINGLE_JUMPS)
                .filter(([key, jump]) => jump.ship === shipUsedOut)
                .map(([key, jump]) => ({ key, mass: jump.mass, label: jump.label }));

            const numSims = Math.floor(CONFIG.simulations / returnModes.length);

            for (const mode of returnModes) {
                let successes = 0;  // Survived return (collapse on return = success!)
                let collapses = 0;  // Hole collapsed

                for (let i = 0; i < numSims; i++) {
                    const originalMass = startMin + Math.random() * (startMax - startMin);
                    const trueRemaining = originalMass - massUsed;

                    // Return jump
                    const afterReturn = trueRemaining - mode.mass;

                    if (afterReturn <= 0) {
                        // Collapsed on return - SUCCESS (we made it home as it closed)
                        successes++;
                        collapses++;
                    } else {
                        // Didn't collapse - we're home safe, hole still open
                        successes++;
                    }
                }

                results.push({
                    key: mode.key,
                    act: { out: 0, back: mode.mass, label: mode.label },
                    mass: mode.mass,
                    successRate: successes / numSims,
                    collapseRate: collapses / numSims,
                    rolloutRate: 0,  // Can't rollout on return - collapse = success
                    successes,
                    total: numSims,
                    avgSteps: 1,
                    guaranteedSafe: true,  // Return is always "safe" - collapse means success
                    isReturn: true
                });
            }

            // Sort by: prefer higher mass (close the hole faster), then by collapse rate
            results.sort((a, b) => {
                // If both might close the hole, prefer the one more likely to close it
                if (a.collapseRate > 0.1 && b.collapseRate > 0.1) {
                    return b.collapseRate - a.collapseRate;
                }
                // Otherwise prefer higher mass
                return b.mass - a.mass;
            });

            return results;
        }

        // Display the strategy analysis
        function displayStrategyAnalysis() {
            const grid = document.getElementById('sequence-grid');
            grid.innerHTML = '';

            if (!recommendedStrategy) {
                highlightRecommendedButton(null);
                return;
            }

            const { sequence, actionResults, nextAction, minRemaining, maxRemaining, isReturn, shipUsedOut, mctsIterations, tripDistribution } = recommendedStrategy;

            // Create container for new horizontal layout
            const container = document.createElement('div');
            container.className = 'mcts-results';

            // Special handling for RETURN recommendations (show return options panel)
            if (isReturn && nextAction) {
                highlightRecommendedButton(nextAction.key);

                const returnResults = recommendedStrategy.returnResults || [];
                const recDiv = document.createElement('div');
                recDiv.className = 'mcts-recommendation';
                recDiv.style.borderColor = '#c46444';
                recDiv.style.background = 'rgba(100, 60, 40, 0.9)';
                recDiv.style.marginBottom = '15px';

                let tableRows = '';
                for (const result of returnResults) {
                    const collPct = (result.collapseRate * 100).toFixed(1);
                    const isTop = result.key === nextAction.key;
                    tableRows += `<tr${isTop ? ' style="background: rgba(100, 80, 60, 0.3);"' : ''}>
                        <td style="padding: 5px 8px; color: ${isTop ? '#fc8' : '#ccc'};">${result.act.label}</td>
                        <td style="padding: 5px 8px; text-align: right;">${result.mass} M</td>
                        <td style="padding: 5px 8px; text-align: right; color: #8f8;">${collPct}%</td>
                    </tr>`;
                }

                recDiv.innerHTML = `
                    <div class="mcts-rec-title" style="color: #faa;">
                        AWAY WITH ${shipUsedOut} â†’ Return: <span style="color: #fff;">${nextAction.act.label}</span>
                        <span class="foolproof-badge" style="background: #4a8a4a;">SAFE HOME</span>
                    </div>
                    <div class="mcts-rec-stats" style="color: #aaa; margin-top: 8px;">
                        <table style="width: 100%; font-size: 0.85em;">
                            <tr style="color: #777;"><th style="text-align: left; padding: 3px 8px;">Return</th><th style="text-align: right; padding: 3px 8px;">Mass</th><th style="text-align: right; padding: 3px 8px;">Closes</th></tr>
                            ${tableRows}
                        </table>
                    </div>
                `;
                container.appendChild(recDiv);
                // Don't return early - continue to show the outbound analysis below
            }

            // Highlight recommended button
            if (nextAction) {
                highlightRecommendedButton(nextAction.key);
            } else {
                highlightRecommendedButton(null);
            }

            // Details row (distribution + comparison side by side)
            if ((tripDistribution && tripDistribution.length > 0) || actionResults.length > 0) {
                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'mcts-details';

                // Left: Trip distribution for top strategy
                if (tripDistribution && tripDistribution.length > 0) {
                    const distDiv = document.createElement('div');
                    distDiv.className = 'mcts-distribution';

                    const topActionLabel = nextAction ? nextAction.act.label : 'Top Strategy';
                    const distItems = tripDistribution
                        .map(d => `<div class="mcts-distribution-item">${d.trips} trips: <strong>${Math.round(d.pct * 100)}%</strong></div>`)
                        .join('');

                    distDiv.innerHTML = `
                        <div class="mcts-distribution-title">Trip Distribution (${topActionLabel})</div>
                        ${distItems}
                        <div class="mcts-distribution-footer">${mctsIterations.toLocaleString()} iterations</div>
                    `;
                    detailsDiv.appendChild(distDiv);
                }

                // Right: Action comparison table
                if (actionResults.length > 0) {
                    const compDiv = document.createElement('div');
                    compDiv.className = 'mcts-comparison';

                    let tableRows = '';
                    for (let i = 0; i < actionResults.length; i++) {
                        const result = actionResults[i];
                        const act = result.act;
                        const mass = (act.out + act.back).toFixed(1);
                        const successPct = (result.successRate * 100).toFixed(0);
                        const scoreInt = Math.round(result.strategyScore * 10000);
                        const scoreColor = result.strategyScore >= 0.90 ? '#8f8' :
                                          (result.strategyScore >= 0.70 ? '#fc8' : '#f88');

                        tableRows += `<tr>
                            <td>${act.label}</td>
                            <td style="text-align: center;">${result.guaranteedSafe ? 'âœ“' : ''}</td>
                            <td style="text-align: right;">${mass} M</td>
                            <td style="text-align: right;">${result.avgSteps.toFixed(1)}</td>
                            <td style="text-align: right;">${successPct}%</td>
                            <td style="text-align: right; color: ${scoreColor}; font-weight: bold;">${scoreInt}</td>
                        </tr>`;
                    }

                    compDiv.innerHTML = `
                        <div class="mcts-comparison-title">Action Comparison</div>
                        <table>
                            <tr>
                                <th>Action<span class="info-icon">?<span class="info-tooltip">Ship configuration (Out/Back)</span></span></th>
                                <th style="text-align: center;">Safe<span class="info-icon">?<span class="info-tooltip">Guaranteed safe outbound (won't get rolled going out)</span></span></th>
                                <th style="text-align: right;">Mass<span class="info-icon">?<span class="info-tooltip">Total mass per round trip</span></span></th>
                                <th style="text-align: right;">Trips<span class="info-icon">?<span class="info-tooltip">Average trips to close the hole</span></span></th>
                                <th style="text-align: right;">Success<span class="info-icon">?<span class="info-tooltip">Chance of strategy terminating the wormhole without being rolled out</span></span></th>
                                <th style="text-align: right;">Score<span class="info-icon">?<span class="info-tooltip">Success weighted by trip count (0-10000, fewer trips = higher)</span></span></th>
                            </tr>
                            ${tableRows}
                        </table>
                    `;
                    detailsDiv.appendChild(compDiv);
                }

                container.appendChild(detailsDiv);
            }

            grid.appendChild(container);
        }

        // Unified single jump recording - direction determined by history
        function recordSingleJump(jumpType) {
            const position = getPosition();
            const jump = SINGLE_JUMPS[jumpType];

            if (position === 'home') {
                // If we have a completed action but no observation, assume 'fresh'
                if (lastCompletedAction && !lastObservation) {
                    lastObservation = 'fresh';
                }

                // Outbound jump
                state.massUsed += jump.mass;
                state.history.push({
                    type: 'jump-out-' + jumpType,
                    label: jump.label + ' â†’',
                    mass: jump.mass,
                    ship: jump.ship,
                    timestamp: new Date().toLocaleTimeString()
                });
            } else {
                // Return jump - enforce same ship
                const shipUsedOut = getShipUsedOut();
                if (shipUsedOut && jump.ship !== shipUsedOut) {
                    alert(`You went out with ${shipUsedOut}, you must return with ${shipUsedOut}!`);
                    return;
                }
                state.massUsed += jump.mass;
                state.history.push({
                    type: 'jump-back-' + jumpType,
                    label: 'â† ' + jump.label,
                    mass: jump.mass,
                    ship: jump.ship,
                    timestamp: new Date().toLocaleTimeString()
                });

                // Track completed round-trip action for tree reuse
                lastCompletedAction = getLastCompletedActionKey();
            }

            // After any jump, await observation before next jump
            // Even when crit, user needs to confirm if hole collapsed or stayed crit
            state.awaitingObservation = true;

            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        // Check if observation is REQUIRED (mass bounds make it impossible NOT to have crossed threshold)
        function getRequiredObservation() {
            const massUsed = state.massUsed;
            const maxTotal = state.knownMaxStart;

            // If massUsed >= 90% of maxTotal, hole MUST be crit
            if (massUsed >= maxTotal * (1 - CONFIG.critThreshold)) {
                return 'crit';
            }
            // If massUsed >= 50% of maxTotal, hole MUST have shrunk
            if (massUsed >= maxTotal * CONFIG.shrinkThreshold) {
                return 'shrink';
            }
            return null;
        }

        // Check if a threshold crossing is POSSIBLE (for reminder glow)
        function shouldShowObservationReminder() {
            const massUsed = state.massUsed;
            const minTotal = state.knownMinStart;
            const maxTotal = state.knownMaxStart;

            // Shrink happens when >50% mass used (remaining < 50%)
            // Check if massUsed could have crossed 50% threshold for any mass in [minTotal, maxTotal]
            const shrinkThresholdMin = minTotal * CONFIG.shrinkThreshold;  // 50% of min
            const shrinkThresholdMax = maxTotal * CONFIG.shrinkThreshold;  // 50% of max
            const shrinkPossible = massUsed >= shrinkThresholdMin && massUsed <= shrinkThresholdMax;

            // Crit happens when >90% mass used (remaining < 10%)
            const critThresholdMin = minTotal * (1 - CONFIG.critThreshold);  // 90% of min
            const critThresholdMax = maxTotal * (1 - CONFIG.critThreshold);  // 90% of max
            const critPossible = massUsed >= critThresholdMin && massUsed <= critThresholdMax;

            return shrinkPossible || critPossible;
        }

        // Check if jumps are blocked due to required observation
        function areJumpsBlocked() {
            return getRequiredObservation() !== null && getPosition() === 'home';
        }

        // Highlight the recommended action button
        function highlightRecommendedButton(actionKey) {
            // Clear previous highlights
            document.querySelectorAll('.jump-btn.recommended').forEach(btn => {
                btn.classList.remove('recommended');
            });

            if (!actionKey) return;

            // Map MCTS action keys to outbound jump types
            // MCTS keys are like 'BS_HOT' (round trip), button data-jump is same
            // For round trips like BS_HOT_COLD, we want the outbound (first part)
            let jumpKey = actionKey;
            if (actionKey.includes('_COLD_')) {
                // e.g., BS_COLD_HOT -> outbound is BS_COLD
                jumpKey = actionKey.split('_').slice(0, 2).join('_');
            }

            // Find and highlight the matching button
            const btn = document.querySelector(`.jump-btn[data-jump="${jumpKey}"]`);
            if (btn) {
                btn.classList.add('recommended');
            }
        }

        function recoverFromShrink() {
            clearMctsTree();
            state.massUsed = 0;
            state.knownMinStart = getBaseMass() * (1 - getVariance()) * CONFIG.critThreshold;
            state.knownMaxStart = getBaseMass() * (1 + getVariance()) * CONFIG.shrinkThreshold;
            state.hasUnknownMass = true;
            state.history = [];  // Reset history (position will be home)
            state.history.push({
                type: 'recovery-shrink',
                label: 'Recovered: Hole Shrunk',
                mass: 0,
                note: 'Reset to shrink state (180-1100 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function recoverFromCrit() {
            clearMctsTree();
            state.massUsed = 0;
            state.knownMinStart = 0;
            state.knownMaxStart = getBaseMass() * (1 + getVariance()) * CONFIG.critThreshold;
            state.hasUnknownMass = true;
            state.history = [];  // Reset history (position will be home)
            state.history.push({
                type: 'recovery-crit',
                label: 'Recovered: Hole Crit',
                mass: 0,
                note: 'Reset to crit state (0-220 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        // State change observed while tracking - combine tracking data with state info
        function recordNormalObservation() {
            // Record observation for tree reuse (no state change = fresh)
            lastObservation = 'fresh';

            // Fresh means remaining is still >50% of original
            // This can help narrow the max if we've used significant mass
            const minTotal = state.massUsed / CONFIG.shrinkThreshold;  // massUsed / 0.5 = 2x massUsed
            if (minTotal > state.knownMinStart) {
                state.knownMinStart = Math.ceil(minTotal);
            }

            state.history.push({
                type: 'state-normal',
                label: 'No Change',
                mass: 0,
                note: `Still fresh (>${Math.round(state.knownMinStart - state.massUsed)} M)`,
                timestamp: new Date().toLocaleTimeString()
            });
            state.awaitingObservation = false;
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        // Helper: get mass of the last jump from history
        function getLastJumpMass() {
            for (let i = state.history.length - 1; i >= 0; i--) {
                if (state.history[i].type.startsWith('jump-')) {
                    return state.history[i].mass;
                }
            }
            return 0;
        }

        // Helper: check if hole was fresh before the last jump
        // (no shrink/crit observation, or most recent observation was "normal")
        function wasHoleFreshBeforeLastJump() {
            // Walk backwards through history, skip jumps until we find an observation
            for (let i = state.history.length - 1; i >= 0; i--) {
                const event = state.history[i];
                if (event.type === 'state-normal') {
                    return true;  // Explicitly confirmed fresh
                }
                if (event.type === 'state-shrunk' || event.type === 'state-crit') {
                    return false;  // Was already shrunk/crit
                }
                // Skip jumps and setup events, keep looking
            }
            // No state observation found = hole was fresh (default state)
            return true;
        }

        // Helper: check if hole has ever shrunk (at any point in history)
        function hasHoleShrunk() {
            return state.history.some(e => e.type === 'state-shrunk');
        }

        // Helper: check if hole has ever crit'd (at any point in history)
        function hasHoleCrit() {
            return state.history.some(e => e.type === 'state-crit');
        }

        // Helper: check if hole was shrunk (not fresh, not crit) before the last jump
        function wasHoleShrunkBeforeLastJump() {
            for (let i = state.history.length - 1; i >= 0; i--) {
                const event = state.history[i];
                if (event.type === 'state-shrunk') {
                    return true;  // Was shrunk
                }
                if (event.type === 'state-normal' || event.type === 'state-crit') {
                    return false;  // Was fresh or already crit
                }
            }
            return false;  // No shrunk observation = wasn't shrunk
        }

        function holeJustShrunk() {
            // Record observation for tree reuse
            lastObservation = 'shrink';

            // Shrink observation constrains TOTAL mass bounds:
            // - 10% < remaining/total â‰¤ 50%
            // - total > massUsed/0.9 AND total â‰¤ 2*massUsed
            const baseMin = getBaseMass() * (1 - getVariance());
            const baseMax = getBaseMass() * (1 + getVariance());

            let newMin = state.knownMinStart;
            let newMax = state.knownMaxStart;
            let note;

            if (state.massUsed > 0) {
                // Apply observation constraints to total bounds
                const obsMin = state.massUsed / 0.9 + 1;  // total > massUsed/0.9
                const obsMax = 2 * state.massUsed;        // total â‰¤ 2*massUsed
                newMin = Math.max(newMin, obsMin);
                newMax = Math.min(newMax, obsMax);
            }

            // Validate the intersection
            if (newMin > newMax) {
                // Tracking inconsistent - fall back to visual bounds as TOTAL
                const visualRemainingMin = baseMin * CONFIG.critThreshold;   // 180 M
                const visualRemainingMax = baseMax * CONFIG.shrinkThreshold; // 1100 M
                newMin = state.massUsed + visualRemainingMin;
                newMax = Math.min(baseMax, state.massUsed + visualRemainingMax);
                note = `Tracking inconsistent, reset to ${Math.round(newMin - state.massUsed)}-${Math.round(newMax - state.massUsed)} M remaining`;
                clearMctsTree();
            } else {
                const minRemaining = Math.max(0, newMin - state.massUsed);
                const maxRemaining = newMax - state.massUsed;
                note = `Narrowed to ${Math.round(minRemaining)}-${Math.round(maxRemaining)} M remaining`;
            }

            state.knownMinStart = newMin;
            state.knownMaxStart = newMax;
            state.hasUnknownMass = false;
            // NOTE: Don't reset massUsed - we're using TOTAL bounds now

            state.history.push({
                type: 'state-shrunk',
                label: 'Hole Shrunk',
                mass: state.massUsed,  // Record current mass for replay
                note: note,
                timestamp: new Date().toLocaleTimeString()
            });
            state.awaitingObservation = false;
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function holeJustCrit() {
            // Record observation for tree reuse
            lastObservation = 'crit';

            // Crit observation constrains TOTAL mass bounds:
            // - remaining/total â‰¤ 10%
            // - total â‰¤ massUsed/0.9
            const baseMax = getBaseMass() * (1 + getVariance());

            let newMin = state.knownMinStart;
            let newMax = state.knownMaxStart;
            let note;

            if (state.massUsed > 0) {
                // Apply observation constraint to total bounds
                const obsMax = state.massUsed / 0.9;  // total â‰¤ massUsed/0.9
                newMax = Math.min(newMax, obsMax);
            }

            // Validate the intersection
            if (newMin > newMax) {
                // Tracking inconsistent - fall back to visual bounds as TOTAL
                const visualRemainingMax = baseMax * CONFIG.critThreshold;  // 220 M
                newMin = state.massUsed;  // Could be 0 remaining
                newMax = state.massUsed + visualRemainingMax;
                note = `Tracking inconsistent, reset to 0-${Math.round(visualRemainingMax)} M remaining`;
                clearMctsTree();
            } else {
                const minRemaining = Math.max(0, newMin - state.massUsed);
                const maxRemaining = newMax - state.massUsed;
                note = `Narrowed to ${Math.round(minRemaining)}-${Math.round(maxRemaining)} M remaining`;
            }

            state.knownMinStart = newMin;
            state.knownMaxStart = newMax;
            state.hasUnknownMass = false;
            // NOTE: Don't reset massUsed - we're using TOTAL bounds now

            state.history.push({
                type: 'state-crit',
                label: 'Hole Crit',
                mass: state.massUsed,  // Record current mass for replay
                note: note,
                timestamp: new Date().toLocaleTimeString()
            });
            state.awaitingObservation = false;
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function holeJustClosed() {
            // Record observation for tree reuse
            lastObservation = 'collapsed';

            state.history.push({
                type: 'state-closed',
                label: 'Hole Closed!',
                mass: 0,
                note: 'Wormhole has collapsed - roll complete!',
                timestamp: new Date().toLocaleTimeString()
            });
            state.awaitingObservation = false;
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        // Update observation button states based on awaitingObservation state
        function updateObservationButtons() {
            const normalBtn = document.getElementById('btn-normal');
            const shrunkBtn = document.getElementById('btn-shrunk');
            const critBtn = document.getElementById('btn-crit');
            const closedBtn = document.getElementById('btn-closed');
            if (!normalBtn || !shrunkBtn || !critBtn || !closedBtn) return;

            const required = getRequiredObservation();
            const alreadyShrunk = hasHoleShrunk();
            const alreadyCrit = hasHoleCrit();

            // Start with buttons disabled
            normalBtn.disabled = true;
            shrunkBtn.disabled = true;
            critBtn.disabled = true;
            closedBtn.disabled = true;
            normalBtn.classList.remove('required');
            shrunkBtn.classList.remove('required');
            critBtn.classList.remove('required');
            closedBtn.classList.remove('required');

            // Only enable if awaiting observation after a jump
            if (!state.awaitingObservation) {
                return;
            }

            // CLOSED is always an option when awaiting observation (hole can always close)
            closedBtn.disabled = false;

            if (required === 'crit' || alreadyCrit) {
                // Only crit or closed valid - already crit or must be crit
                critBtn.disabled = false;
                critBtn.classList.add('required');
            } else if (required === 'shrink' || alreadyShrunk) {
                // Hole has shrunk - only shrunk, crit, or closed valid (not normal)
                shrunkBtn.disabled = false;
                critBtn.disabled = false;
                if (required === 'shrink') {
                    shrunkBtn.classList.add('required');
                    critBtn.classList.add('required');
                }
            } else {
                // Fresh hole - all options available
                normalBtn.disabled = false;
                shrunkBtn.disabled = false;
                critBtn.disabled = false;
            }
        }

        // Initialize state selection UI
        function initStateSelection() {
            const radios = document.querySelectorAll('input[name="hole-state"]');
            radios.forEach(radio => {
                radio.addEventListener('change', updateStateSelection);
            });
            updateStateSelection();  // Set initial state
        }

        function updateStateSelection() {
            const selected = document.querySelector('input[name="hole-state"]:checked')?.value || 'fresh';
            document.querySelectorAll('.state-option').forEach(opt => opt.classList.remove('selected'));
            document.getElementById('state-' + selected)?.classList.add('selected');
        }

        // Unified hole setup function
        function applyHoleSetup() {
            const visualState = document.querySelector('input[name="hole-state"]:checked')?.value || 'fresh';
            const massInput = document.getElementById('setup-mass-input');
            const massUsed = parseFloat(massInput.value) || 0;

            if (massUsed < 0) {
                alert('Mass cannot be negative');
                return;
            }

            clearMctsTree();

            // Calculate belief bounds based on visual state
            const baseMin = getBaseMass() * (1 - getVariance());  // 1800
            const baseMax = getBaseMass() * (1 + getVariance());  // 2200
            const shrinkThreshold = CONFIG.shrinkThreshold;  // 0.5
            const critThreshold = CONFIG.critThreshold;      // 0.1

            let minStart, maxStart, label, note;

            if (visualState === 'fresh') {
                // Fresh: Confirmed new hole, no untracked passes
                // If mass tracked, total > 2 * massUsed (still fresh means >50% remaining)
                minStart = Math.max(baseMin, massUsed > 0 ? 2 * massUsed + 1 : baseMin);
                maxStart = baseMax;
                label = 'Setup: Fresh';
                note = `Fresh hole${massUsed > 0 ? ', â‰¥' + massUsed + 'M passed' : ''} â†’ ${Math.round(minStart)}-${Math.round(maxStart)}M total`;
            } else if (visualState === 'normal') {
                // Normal: Looks >50% but may have untracked passes
                // Could be just above 50% of minimum total (900M for C247)
                const normalMin = baseMin * shrinkThreshold;  // 900M (50% of min total)
                minStart = normalMin;
                maxStart = baseMax;  // 2200M
                label = 'Setup: Normal';
                note = `Normal state (may have passes) â†’ ${Math.round(minStart)}-${Math.round(maxStart)}M remaining`;
            } else if (visualState === 'reduced') {
                // Reduced: 10-50% remaining
                // We need TOTAL mass bounds, not remaining bounds
                // Observation constraints:
                //   - remaining > 10% of total: total > massUsed / 0.9
                //   - remaining â‰¤ 50% of total: total â‰¤ 2 * massUsed
                // Visual remaining bounds: 180-1100M (10-50% of base variance)
                const visualRemainingMin = baseMin * critThreshold;  // 180M
                const visualRemainingMax = baseMax * shrinkThreshold;  // 1100M

                // Compute total bounds from observation constraints
                const obsConstraintMin = massUsed > 0 ? massUsed / 0.9 + 1 : baseMin;
                const obsConstraintMax = massUsed > 0 ? 2 * massUsed : baseMax;

                // Compute total bounds from visual remaining bounds
                const visualTotalMin = massUsed + visualRemainingMin;
                const visualTotalMax = massUsed + visualRemainingMax;

                // Combine all constraints
                minStart = Math.max(baseMin, obsConstraintMin, visualTotalMin);
                maxStart = Math.min(baseMax, obsConstraintMax, visualTotalMax);

                // If invalid, fall back to visual bounds (indicates untracked mass)
                if (minStart >= maxStart) {
                    minStart = massUsed + visualRemainingMin;
                    maxStart = Math.min(baseMax, massUsed + visualRemainingMax);
                }

                // Final validation
                if (minStart >= maxStart) {
                    alert(`With â‰¥${massUsed}M passed, the hole cannot be reduced (would be critical or collapsed).`);
                    return;
                }

                const minRemaining = Math.max(0, minStart - massUsed);
                const maxRemaining = maxStart - massUsed;
                label = 'Setup: Reduced';
                note = `Reduced state, â‰¥${massUsed}M passed â†’ ${Math.round(minRemaining)}-${Math.round(maxRemaining)}M remaining`;
            } else {  // critical
                // Critical: <10% remaining
                // We need TOTAL mass bounds, not remaining bounds
                // Observation constraint: remaining/total â‰¤ 10%, so total â‰¤ massUsed/0.9
                // Also: remaining = total - massUsed â‰¤ 220 (10% of max total 2200)
                // So: total â‰¤ massUsed + 220
                const critConstraint = massUsed > 0 ? massUsed / 0.9 : baseMax;
                const visualConstraint = massUsed + baseMax * critThreshold;  // massUsed + 220

                // Total must be > massUsed (hole hasn't collapsed) and within base variance
                minStart = Math.max(baseMin, massUsed + 1);
                maxStart = Math.min(baseMax, critConstraint, visualConstraint);

                // Validate: if min >= max, the scenario is impossible
                if (minStart >= maxStart) {
                    // With small massUsed, we can't constrain total - use visual bounds only
                    // This means untracked mass exists; remaining is simply 0-220
                    minStart = massUsed;  // Could be 0 remaining
                    maxStart = massUsed + baseMax * critThreshold;  // At most 220 remaining
                }

                // Final validation
                if (maxStart <= massUsed) {
                    alert(`With â‰¥${massUsed}M passed, the hole should be collapsed, not critical.`);
                    return;
                }

                const minRemaining = Math.max(0, minStart - massUsed);
                const maxRemaining = maxStart - massUsed;
                label = 'Setup: Critical';
                note = `Critical state, â‰¥${massUsed}M passed â†’ ${Math.round(minRemaining)}-${Math.round(maxRemaining)}M remaining`;
            }

            state.massUsed = massUsed;
            state.knownMinStart = minStart;
            state.knownMaxStart = maxStart;
            state.hasUnknownMass = massUsed === 0;
            state.history = [];
            state.history.push({
                type: 'setup-' + visualState,
                label: label,
                mass: massUsed,
                note: note,
                timestamp: new Date().toLocaleTimeString()
            });

            massInput.value = '';
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function copyEventLog() {
            const minRemaining = Math.max(0, state.knownMinStart - state.massUsed);
            const maxRemaining = Math.max(0, state.knownMaxStart - state.massUsed);

            let markdown = `## Wormhole Roll Log\n\n`;
            markdown += `**Mass Estimate:** ${Math.round(minRemaining)}-${Math.round(maxRemaining)} M remaining\n\n`;

            if (state.history.length === 0) {
                markdown += `*No events recorded*\n`;
            } else {
                markdown += `### Event Log\n\n`;
                state.history.forEach((item, i) => {
                    if (item.type.startsWith('jump-')) {
                        markdown += `${i + 1}. **${item.label}** (-${item.mass} M)\n`;
                    } else if (item.type.startsWith('state-')) {
                        markdown += `${i + 1}. *${item.label}* â€” ${item.note}\n`;
                    } else if (item.type.startsWith('setup')) {
                        markdown += `${i + 1}. Setup: ${item.note}\n`;
                    }
                });
            }

            // Add MCTS analysis if available
            if (recommendedStrategy && recommendedStrategy.actionResults) {
                const results = recommendedStrategy.actionResults;
                if (results.length > 0) {
                    markdown += `\n### Action Comparison\n\n`;
                    markdown += `| Action | Safe | Mass | Trips | Success | Score |\n`;
                    markdown += `|--------|------|------|-------|---------|-------|\n`;
                    for (const result of results) {
                        const mass = (result.act.out + result.act.back).toFixed(1);
                        const successPct = (result.successRate * 100).toFixed(0);
                        const scoreInt = Math.round(result.strategyScore * 10000);
                        const safe = result.guaranteedSafe ? 'âœ“' : '';
                        markdown += `| ${result.act.label} | ${safe} | ${mass} M | ${result.avgSteps.toFixed(1)} | ${successPct}% | ${scoreInt} |\n`;
                    }
                }

                const dist = recommendedStrategy.tripDistribution;
                if (dist && dist.length > 0) {
                    const topLabel = results.length > 0 ? results[0].act.label : 'Top Strategy';
                    markdown += `\n### Trip Distribution (${topLabel})\n\n`;
                    for (const d of dist) {
                        markdown += `- ${d.trips} trips: ${Math.round(d.pct * 100)}%\n`;
                    }
                }

                if (recommendedStrategy.mctsIterations) {
                    markdown += `\n*${recommendedStrategy.mctsIterations.toLocaleString()} MCTS iterations*\n`;
                }
            }

            navigator.clipboard.writeText(markdown).then(() => {
                // Brief visual feedback
                const btn = document.querySelector('.observation-buttons-vertical .btn-copy');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = original, 1500);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        function copyFitting(elementId) {
            const pre = document.getElementById(elementId);
            if (!pre) return;

            const text = pre.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button in the same container
                const container = pre.closest('.fitting-text-container');
                const btn = container ? container.querySelector('.fitting-copy-btn') : null;
                if (btn) {
                    const original = btn.innerHTML;
                    btn.innerHTML = '&#10003;';  // Checkmark
                    btn.style.color = '#8f8';
                    setTimeout(() => {
                        btn.innerHTML = original;
                        btn.style.color = '';
                    }, 1500);
                }
            }).catch(err => {
                console.error('Failed to copy fitting:', err);
                alert('Failed to copy to clipboard');
            });
        }

        function undoLast() {
            if (state.history.length > 0) {
                const last = state.history.pop();
                if (last.type.startsWith('setup')) {
                    // Setup actions cannot be undone - they reset everything
                    alert('Setup actions cannot be undone. Use a new setup instead.');
                    state.history.push(last);
                } else if (last.type.startsWith('state-')) {
                    // State changes (shrunk/crit/normal) CAN be undone
                    // We need to restore the previous belief state
                    // Since state changes reset massUsed to 0, we need to restore from history
                    // For simplicity, just clear and rebuild from remaining history
                    clearMctsTree();
                    rebuildStateFromHistory();
                    // After undoing an observation, we're back to awaiting observation (unless already crit)
                    state.awaitingObservation = !hasHoleCrit();
                } else {
                    // Normal jump - just subtract mass
                    state.massUsed -= last.mass;
                    clearMctsTree();
                    // After undoing a jump, we're no longer awaiting observation
                    state.awaitingObservation = false;
                }
                saveState();
                setTimeout(() => {
                    runStrategyAnalysis();
                    updateDisplay();
                }, 10);
            }
        }

        // Rebuild state from history after undoing a state change
        function rebuildStateFromHistory() {
            // Find the last setup entry
            let setupIndex = -1;
            for (let i = state.history.length - 1; i >= 0; i--) {
                if (state.history[i].type.startsWith('setup')) {
                    setupIndex = i;
                    break;
                }
            }

            if (setupIndex === -1) {
                // No setup found, reset to fresh
                state.massUsed = 0;
                state.knownMinStart = getBaseMass() * (1 - getVariance());
                state.knownMaxStart = getBaseMass() * (1 + getVariance());
                state.hasUnknownMass = false;
            } else {
                // Replay from setup - use same logic as applyHoleSetup
                const setup = state.history[setupIndex];
                const setupMass = setup.mass || 0;
                const baseMin = getBaseMass() * (1 - getVariance());
                const baseMax = getBaseMass() * (1 + getVariance());

                if (setup.type === 'setup-fresh' || setup.type === 'setup-normal') {
                    // Fresh/Normal: total bounds, constrained by massUsed if applicable
                    state.knownMinStart = Math.max(baseMin, setupMass > 0 ? 2 * setupMass + 1 : baseMin);
                    state.knownMaxStart = baseMax;
                } else if (setup.type === 'setup-reduced') {
                    // Reduced: compute TOTAL bounds from constraints
                    const visualRemainingMin = baseMin * CONFIG.critThreshold;
                    const visualRemainingMax = baseMax * CONFIG.shrinkThreshold;
                    const obsMin = setupMass > 0 ? setupMass / 0.9 + 1 : baseMin;
                    const obsMax = setupMass > 0 ? 2 * setupMass : baseMax;
                    state.knownMinStart = Math.max(baseMin, obsMin, setupMass + visualRemainingMin);
                    state.knownMaxStart = Math.min(baseMax, obsMax, setupMass + visualRemainingMax);
                    // Fallback for untracked mass scenario
                    if (state.knownMinStart >= state.knownMaxStart) {
                        state.knownMinStart = setupMass + visualRemainingMin;
                        state.knownMaxStart = Math.min(baseMax, setupMass + visualRemainingMax);
                    }
                } else if (setup.type === 'setup-critical') {
                    // Critical: compute TOTAL bounds from constraints
                    const critConstraint = setupMass > 0 ? setupMass / 0.9 : baseMax;
                    const visualConstraint = setupMass + baseMax * CONFIG.critThreshold;
                    state.knownMinStart = Math.max(baseMin, setupMass + 1);
                    state.knownMaxStart = Math.min(baseMax, critConstraint, visualConstraint);
                    // Fallback for untracked mass scenario
                    if (state.knownMinStart >= state.knownMaxStart) {
                        state.knownMinStart = setupMass;
                        state.knownMaxStart = setupMass + baseMax * CONFIG.critThreshold;
                    }
                } else {
                    // Legacy setup types
                    state.knownMinStart = baseMin;
                    state.knownMaxStart = baseMax;
                }
                state.massUsed = setupMass;
                state.hasUnknownMass = setupMass === 0;
            }

            // Replay all jumps and state changes after setup
            for (let i = setupIndex + 1; i < state.history.length; i++) {
                const entry = state.history[i];
                if (entry.type.startsWith('jump-')) {
                    state.massUsed += entry.mass;
                } else if (entry.type === 'state-shrunk') {
                    // Apply shrink observation constraint to TOTAL bounds
                    // Shrink means: 10% < remaining/total â‰¤ 50%
                    // Which gives: total > massUsed/0.9 AND total â‰¤ 2*massUsed
                    if (state.massUsed > 0) {
                        state.knownMinStart = Math.max(state.knownMinStart, state.massUsed / 0.9 + 1);
                        state.knownMaxStart = Math.min(state.knownMaxStart, 2 * state.massUsed);
                    }
                    state.hasUnknownMass = false;
                } else if (entry.type === 'state-crit') {
                    // Apply crit observation constraint to TOTAL bounds
                    // Crit means: remaining/total â‰¤ 10%
                    // Which gives: total â‰¤ massUsed/0.9
                    if (state.massUsed > 0) {
                        state.knownMaxStart = Math.min(state.knownMaxStart, state.massUsed / 0.9);
                    }
                    state.hasUnknownMass = false;
                }
            }
        }

        function resetCalculator() {
            if (confirm('Reset all tracking? This cannot be undone.')) {
                clearMctsTree();
                state = {
                    massUsed: 0,
                    history: [],
                    hasUnknownMass: false,
                    knownMinStart: getBaseMass() * (1 - getVariance()),
                    knownMaxStart: getBaseMass() * (1 + getVariance()),
                    awaitingObservation: false
                };
                saveState();
                setTimeout(() => {
                    runStrategyAnalysis();
                    updateDisplay();
                }, 10);
            }
        }

        // Update jump button labels based on position
        function updateJumpButtons(position, shipUsedOut) {
            const requiredObs = getRequiredObservation();
            // Block jumps if awaiting observation OR if observation is required
            const jumpsBlocked = state.awaitingObservation || (requiredObs !== null && position === 'home');

            const buttons = document.querySelectorAll('.jump-btn');
            buttons.forEach(btn => {
                const jumpType = btn.dataset.jump;
                const jump = SINGLE_JUMPS[jumpType];
                if (!jump) return;

                const isWrongShip = position === 'away' && shipUsedOut && jump.ship !== shipUsedOut;

                // Update label
                if (position === 'home') {
                    btn.innerHTML = `${jump.label} â†’<br><span style="font-size: 0.8em; opacity: 0.8;">${jump.mass} M</span>`;
                } else {
                    btn.innerHTML = `â† ${jump.label}<br><span style="font-size: 0.8em; opacity: 0.8;">${jump.mass} M</span>`;
                }

                // Update styling based on position, ship constraint, and observation requirement
                if (isWrongShip || jumpsBlocked) {
                    btn.disabled = true;
                    btn.style.opacity = '0.3';
                    btn.style.cursor = 'not-allowed';
                } else {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                }
            });

            // Update direction label
            const dirLabel = document.getElementById('direction-label');
            if (dirLabel) {
                if (state.awaitingObservation) {
                    if (requiredObs === 'crit') {
                        dirLabel.innerHTML = `<span style="color: #f88;">âš  Record observation (must be CRIT)</span>`;
                    } else if (requiredObs === 'shrink') {
                        dirLabel.innerHTML = `<span style="color: #fc8;">âš  Record observation (SHRUNK or CRIT)</span>`;
                    } else {
                        dirLabel.innerHTML = `<span style="color: #8af;">â† Record observation</span>`;
                    }
                    dirLabel.style.color = '#8af';
                } else if (position === 'away') {
                    dirLabel.textContent = `â† Jumping BACK (${shipUsedOut})`;
                    dirLabel.style.color = '#faa';
                } else {
                    dirLabel.textContent = 'â†’ Jumping OUT';
                    dirLabel.style.color = '#8f8';
                }
            }

            // Update the action panel border color
            const actionPanel = document.getElementById('action-panel');
            if (actionPanel) {
                if (position === 'away') {
                    actionPanel.style.borderColor = '#c46444';
                    actionPanel.style.background = 'rgba(80, 40, 30, 0.4)';
                } else {
                    actionPanel.style.borderColor = '#4a8a6a';
                    actionPanel.style.background = 'rgba(30, 60, 50, 0.4)';
                }
            }
        }

        function updateDisplay() {
            const minRemaining = Math.max(0, state.knownMinStart - state.massUsed);
            const maxRemaining = Math.max(0, state.knownMaxStart - state.massUsed);
            const avgRemaining = (minRemaining + maxRemaining) / 2;

            // Update mass bar
            const massBar = document.getElementById('mass-bar');
            const avgPercent = (avgRemaining / getBaseMass()) * 100;
            massBar.style.width = avgPercent + '%';

            // Update variance overlay
            const overlay = document.getElementById('variance-overlay');
            const minPercent = (minRemaining / (getBaseMass() * 1.1)) * 100;
            const maxPercent = (maxRemaining / (getBaseMass() * 1.1)) * 100;
            overlay.style.left = minPercent + '%';
            overlay.style.width = (maxPercent - minPercent) + '%';

            // Variance labels
            document.getElementById('var-min-label').textContent = Math.round(minRemaining) + ' M';
            document.getElementById('var-max-label').textContent = Math.round(maxRemaining) + ' M';

            // Determine status based on average
            let status, statusClass;
            if (avgRemaining <= getCritThreshold()) {
                status = 'CRITICAL';
                statusClass = 'crit';
            } else if (avgRemaining <= getShrinkThreshold()) {
                status = 'SHRUNK';
                statusClass = 'shrink';
            } else {
                status = 'FRESH';
                statusClass = 'fresh';
            }

            massBar.className = 'mass-bar ' + statusClass;
            document.getElementById('status-badge').className = 'status-badge status-' + statusClass;
            document.getElementById('status-badge').textContent = status;

            // Update position badge and jump buttons
            const position = getPosition();
            const shipUsedOut = getShipUsedOut();
            const positionBadge = document.getElementById('position-badge');

            if (position === 'away') {
                positionBadge.textContent = 'AWAY';
                positionBadge.style.background = 'rgba(196, 100, 68, 0.3)';
                positionBadge.style.borderColor = '#c46444';
                positionBadge.style.color = '#faa';
            } else {
                positionBadge.textContent = 'HOME';
                positionBadge.style.background = 'rgba(74, 138, 74, 0.3)';
                positionBadge.style.borderColor = '#4a8a4a';
                positionBadge.style.color = '#8f8';
            }

            // Update jump button labels and states
            updateJumpButtons(position, shipUsedOut);

            // Update displays
            document.getElementById('mass-remaining').textContent = Math.round(avgRemaining) + ' M';
            document.getElementById('range-min').textContent = Math.round(minRemaining);
            document.getElementById('range-max').textContent = Math.round(maxRemaining);

            updateHistory();
            updateObservationButtons();
        }

        function updateHistory() {
            const container = document.getElementById('history-list');

            if (state.history.length === 0) {
                container.innerHTML = '<div class="history-item"><span class="action">No jumps recorded</span></div>';
                return;
            }

            container.innerHTML = state.history.slice().reverse().map(item => {
                const massClass = item.type.startsWith('recovery') ? 'recovery' : 'negative';
                const massDisplay = item.type.startsWith('recovery')
                    ? item.note
                    : ('-' + item.mass + ' M');

                return `
                    <div class="history-item">
                        <span class="action">${item.timestamp} - ${item.label}</span>
                        <span class="mass-change ${massClass}">${massDisplay}</span>
                    </div>
                `;
            }).join('');
        }

        function saveState() {
            localStorage.setItem('wh-calc-state', JSON.stringify(state));
        }

        function loadState() {
            // Try new key first, then migrate from old key
            let saved = localStorage.getItem('wh-calc-state');
            if (!saved) {
                const oldSaved = localStorage.getItem('eedvr-wh-calc-v2');
                if (oldSaved) {
                    saved = oldSaved;
                    localStorage.setItem('wh-calc-state', oldSaved);
                    localStorage.removeItem('eedvr-wh-calc-v2');
                }
            }
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    state = {
                        ...state,
                        ...loaded
                    };
                } catch (e) {
                    console.error('Failed to load saved state');
                }
            }
        }

        window.onload = init;
    </script>
</body>
</html>
