<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EEDVR Wormhole Rolling Calculator | J215101</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            min-height: 100vh;
            color: #e0e0ff;
            overflow-x: hidden;
            position: relative;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .wormhole-bg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 800px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }

        .wormhole-ring {
            position: absolute;
            border: 2px solid;
            border-radius: 50%;
            animation: pulse 4s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(20, 20, 50, 0.8);
            border: 1px solid #4a4a8a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(100, 100, 200, 0.3);
        }

        h1 {
            color: #8af;
            font-size: 1.8em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(136, 170, 255, 0.5);
        }

        .system-info {
            color: #aaa;
            font-size: 0.9em;
        }

        .system-info span {
            color: #6cf;
        }

        .wh-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .spec-card {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .spec-card h3 {
            color: #7af;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .spec-card .value {
            color: #fff;
            font-size: 1.4em;
            font-weight: bold;
        }

        .spec-card .unit {
            color: #888;
            font-size: 0.8em;
        }

        .mass-display {
            background: rgba(20, 20, 50, 0.9);
            border: 2px solid #4a4a8a;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            text-align: center;
        }

        .mass-bar-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            height: 50px;
            margin: 20px 0;
            overflow: visible;
            position: relative;
            border: 1px solid #3a3a6a;
        }

        .mass-bar {
            height: 100%;
            transition: width 0.5s ease, background 0.5s ease;
            border-radius: 10px;
            position: absolute;
            top: 0;
            left: 0;
        }

        .mass-bar.fresh {
            background: linear-gradient(90deg, #2d5a2d, #4a8a4a);
            box-shadow: 0 0 20px rgba(74, 138, 74, 0.5);
        }

        .mass-bar.shrink {
            background: linear-gradient(90deg, #8a6a2d, #c4a044);
            box-shadow: 0 0 20px rgba(196, 160, 68, 0.5);
        }

        .mass-bar.crit {
            background: linear-gradient(90deg, #8a2d2d, #c44444);
            box-shadow: 0 0 20px rgba(196, 68, 68, 0.5);
            animation: critPulse 1s infinite;
        }

        .variance-overlay {
            position: absolute;
            top: 0;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.1) 2px,
                rgba(255, 255, 255, 0.1) 4px
            );
            border-radius: 10px;
            pointer-events: none;
            border-left: 2px dashed rgba(255, 100, 100, 0.8);
            border-right: 2px dashed rgba(100, 255, 100, 0.8);
        }

        .variance-label {
            position: absolute;
            top: -20px;
            font-size: 0.7em;
            white-space: nowrap;
        }

        .variance-label.min {
            color: #f88;
        }

        .variance-label.max {
            color: #8f8;
        }

        @keyframes critPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .mass-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .mass-remaining {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }

        .variance-range {
            font-size: 1em;
            color: #aaa;
            margin-bottom: 10px;
        }

        .variance-range .min { color: #f88; }
        .variance-range .max { color: #8f8; }

        .status-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .status-fresh {
            background: rgba(74, 138, 74, 0.3);
            border: 2px solid #4a8a4a;
            color: #8f8;
        }

        .status-shrink {
            background: rgba(196, 160, 68, 0.3);
            border: 2px solid #c4a044;
            color: #fc8;
        }

        .status-crit {
            background: rgba(196, 68, 68, 0.3);
            border: 2px solid #c44444;
            color: #f88;
            animation: critPulse 1s infinite;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-section {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
        }

        .control-section h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-cold {
            background: linear-gradient(135deg, #2a4a6a, #3a6a9a);
            color: #adf;
            border: 1px solid #4a8aaa;
        }

        .btn-cold:hover {
            background: linear-gradient(135deg, #3a5a7a, #4a7aaa);
            box-shadow: 0 0 15px rgba(100, 150, 200, 0.5);
        }

        .btn-hot {
            background: linear-gradient(135deg, #6a3a2a, #9a5a3a);
            color: #fca;
            border: 1px solid #aa6a4a;
        }

        .btn-hot:hover {
            background: linear-gradient(135deg, #7a4a3a, #aa6a4a);
            box-shadow: 0 0 15px rgba(200, 100, 80, 0.5);
        }

        .btn-recovery {
            background: linear-gradient(135deg, #4a3a6a, #6a4a9a);
            color: #daf;
            border: 1px solid #8a6aaa;
        }

        .btn-recovery:hover {
            background: linear-gradient(135deg, #5a4a7a, #7a5aaa);
            box-shadow: 0 0 15px rgba(150, 100, 200, 0.5);
        }

        .btn-reset {
            background: linear-gradient(135deg, #3a3a3a, #5a5a5a);
            color: #ccc;
            border: 1px solid #6a6a6a;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #4a4a4a, #6a6a6a);
        }

        .btn-undo {
            background: linear-gradient(135deg, #5a4a2a, #7a6a3a);
            color: #ed9;
            border: 1px solid #8a7a4a;
        }

        .btn-undo:hover {
            background: linear-gradient(135deg, #6a5a3a, #8a7a4a);
        }

        /* Monte Carlo Section */
        .monte-carlo {
            background: rgba(20, 40, 60, 0.9);
            border: 2px solid #2a6a8a;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .monte-carlo h3 {
            color: #6cf;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .monte-carlo h3::before {
            content: "ðŸŽ²";
        }

        .simulation-info {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .sequence-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .sequence-card {
            background: rgba(30, 40, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #3a5a7a;
        }

        .sequence-card.safe {
            border-color: #4a8a4a;
            background: rgba(30, 60, 40, 0.8);
        }

        .sequence-card.risky {
            border-color: #8a6a2a;
            background: rgba(60, 50, 30, 0.8);
        }

        .sequence-card.dangerous {
            border-color: #8a3a3a;
            background: rgba(60, 30, 30, 0.8);
        }

        .sequence-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .sequence-detail {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .probability-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .probability-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .probability-fill.safe {
            background: linear-gradient(90deg, #2d8a2d, #4aca4a);
        }

        .probability-fill.risky {
            background: linear-gradient(90deg, #8a6a2d, #caa044);
        }

        .probability-fill.dangerous {
            background: linear-gradient(90deg, #8a2d2d, #ca4444);
        }

        .probability-text {
            font-size: 1.3em;
            font-weight: bold;
        }

        .probability-text.safe { color: #8f8; }
        .probability-text.risky { color: #fc8; }
        .probability-text.dangerous { color: #f88; }

        .foolproof-badge {
            display: inline-block;
            background: linear-gradient(135deg, #2a6a2a, #4a9a4a);
            color: #fff;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 10px;
            text-transform: uppercase;
        }

        .history {
            background: rgba(20, 20, 50, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .history h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .history-item {
            padding: 8px;
            border-bottom: 1px solid rgba(60, 60, 100, 0.5);
            display: flex;
            justify-content: space-between;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-item .action {
            color: #aaa;
        }

        .history-item .mass-change {
            font-weight: bold;
        }

        .history-item .mass-change.negative {
            color: #f88;
        }

        .history-item .mass-change.recovery {
            color: #8f8;
        }

        .recovery-section {
            background: rgba(80, 40, 80, 0.3);
            border: 2px solid #8a4a8a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .recovery-section h3 {
            color: #faf;
            margin-bottom: 10px;
        }

        .recovery-section p {
            color: #caa;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .prediction {
            background: rgba(30, 30, 60, 0.9);
            border: 1px solid #3a3a6a;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .prediction h3 {
            color: #8af;
            margin-bottom: 15px;
            font-size: 1em;
            border-bottom: 1px solid #3a3a6a;
            padding-bottom: 10px;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
        }

        .prediction-item {
            background: rgba(40, 40, 70, 0.5);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .prediction-item .label {
            color: #888;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .prediction-item .value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .warning { color: #f88; }
        .safe { color: #8f8; }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.8em;
        }

        footer a {
            color: #88f;
        }

        @media (max-width: 600px) {
            .controls {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.3em;
            }

            .mass-remaining {
                font-size: 1.8em;
            }

            .sequence-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div class="wormhole-bg" id="wormhole-bg"></div>

    <div class="container">
        <header>
            <h1>EEDVR Wormhole Rolling Calculator</h1>
            <div class="system-info">
                Home System: <span>J215101</span> | Static: <span>C247 (C3 Static)</span>
            </div>
        </header>

        <!-- 1. SETUP: First thing user does -->
        <div class="recovery-section" style="border-color: #2a8a6a; background: rgba(40, 80, 60, 0.3);">
            <h3 style="color: #6fa;">1. Hole Setup</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Left column: Known state -->
                <div>
                    <div style="color: #8cf; font-size: 0.9em; margin-bottom: 10px; border-bottom: 1px solid #3a6a5a; padding-bottom: 5px;">Known State</div>

                    <button class="btn-recovery" style="width: 100%; margin-bottom: 10px; background: linear-gradient(135deg, #2a6a4a, #3a8a6a);" onclick="setFreshHole()">
                        Fresh Hole (1800-2200 M)
                    </button>

                    <div style="color: #888; font-size: 0.8em; margin-bottom: 5px;">Import from tracker:</div>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="known-mass-input" placeholder="Mass (M)"
                               style="flex: 1; padding: 8px; border-radius: 6px; border: 1px solid #4a8aaa;
                                      background: rgba(20, 30, 50, 0.9); color: #adf; font-family: 'Courier New', monospace; font-size: 0.9em;">
                        <button class="btn-cold" style="padding: 8px 12px;" onclick="applyKnownMass()">
                            Apply
                        </button>
                    </div>
                </div>

                <!-- Right column: Unknown mass recovery -->
                <div>
                    <div style="color: #fc8; font-size: 0.9em; margin-bottom: 10px; border-bottom: 1px solid #6a5a3a; padding-bottom: 5px;">Unknown Mass (by visual state)</div>

                    <button class="btn-recovery" style="width: 100%; margin-bottom: 8px; background: linear-gradient(135deg, #5a6a2a, #7a8a3a);" onclick="setUnknownFresh()">
                        Still Fresh (900-2200 M)
                    </button>
                    <button class="btn-recovery" style="width: 100%; margin-bottom: 8px; background: linear-gradient(135deg, #6a5a2a, #8a7a3a);" onclick="recoverFromShrink()">
                        Shrunk (180-1100 M)
                    </button>
                    <button class="btn-recovery" style="width: 100%; background: linear-gradient(135deg, #6a3a3a, #8a4a4a);" onclick="recoverFromCrit()">
                        Critical (0-220 M)
                    </button>
                </div>
            </div>
        </div>

        <!-- 2. CURRENT STATE: Shows mass after setup -->
        <div class="mass-display">
            <h3 style="color: #8af; margin-bottom: 15px;">2. Current Mass Estimate</h3>
            <div class="mass-bar-container">
                <div class="mass-bar fresh" id="mass-bar" style="width: 100%"></div>
                <div class="variance-overlay" id="variance-overlay">
                    <span class="variance-label min" id="var-min-label"></span>
                    <span class="variance-label max" id="var-max-label" style="right: 0;"></span>
                </div>
            </div>
            <div class="mass-labels">
                <span>0%</span>
                <span>10% CRIT</span>
                <span>50% SHRINK</span>
                <span>100%</span>
            </div>
            <div class="mass-remaining" id="mass-remaining">2,000 M</div>
            <div class="variance-range" id="variance-range">
                Possible range: <span class="min" id="range-min">1800</span> - <span class="max" id="range-max">2200</span> M
            </div>
            <div class="status-badge status-fresh" id="status-badge">FRESH</div>
        </div>

        <!-- 3. RECORD: Actions and Observations side by side -->
        <div class="controls" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
            <div class="control-section">
                <h3>3a. Battleship</h3>
                <div class="btn-group">
                    <button class="btn-hot" onclick="recordJump('bs-hot-hot')">
                        HOT/HOT (-600 M)
                    </button>
                    <button class="btn-cold" onclick="recordJump('bs-cold-hot')">
                        COLD/HOT (-500 M)
                    </button>
                    <button class="btn-cold" onclick="recordJump('bs-cold-cold')">
                        COLD/COLD (-400 M)
                    </button>
                </div>
            </div>
            <div class="control-section">
                <h3>3b. HIC (Devoter)</h3>
                <div class="btn-group">
                    <button class="btn-hot" onclick="recordJump('hic-hot-hot')" style="background: linear-gradient(135deg, #5a4a3a, #7a6a4a);">
                        HOT/HOT (-268 M)
                    </button>
                    <button class="btn-cold" onclick="recordJump('hic-cold-cold')" style="background: linear-gradient(135deg, #2a5a5a, #3a7a7a);">
                        COLD/COLD (-60 M)
                    </button>
                    <button class="btn-recovery" onclick="recordJump('hic-ent-ent')" style="background: linear-gradient(135deg, #4a2a5a, #6a3a7a);">
                        ENT/ENT (-3 M)
                    </button>
                </div>
            </div>
            <div class="control-section">
                <h3>3c. One-Way</h3>
                <div class="btn-group">
                    <button class="btn-hot" onclick="recordJump('bs-hot-one')">
                        BS Hot (-300 M)
                    </button>
                    <button class="btn-cold" onclick="recordJump('bs-cold-one')">
                        BS Cold (-200 M)
                    </button>
                    <button class="btn-recovery" onclick="recordJump('hic-ent-one')" style="background: linear-gradient(135deg, #4a2a5a, #6a3a7a);">
                        HIC Ent (-1.5 M)
                    </button>
                </div>
            </div>
            <div class="control-section" style="border-color: #8a6a2a; background: rgba(80, 60, 30, 0.4);">
                <h3 style="color: #fc8;">3d. Observed State</h3>
                <div class="btn-group">
                    <button class="btn-recovery" onclick="holeJustShrunk()" style="background: linear-gradient(135deg, #7a6a2a, #9a8a3a); border-color: #ba9a4a; font-size: 1.1em; padding: 15px;">
                        HOLE SHRUNK
                    </button>
                    <button class="btn-recovery" onclick="holeJustCrit()" style="background: linear-gradient(135deg, #7a3a3a, #9a4a4a); border-color: #ba5a5a; font-size: 1.1em; padding: 15px;">
                        HOLE CRIT
                    </button>
                </div>
                <div style="color: #aaa; font-size: 0.75em; margin-top: 8px; text-align: center;">
                    Narrows estimate using visual state
                </div>
            </div>
        </div>

        <!-- 4. ANALYSIS: MCTS Strategy recommendation -->
        <div class="monte-carlo">
            <h3>4. MCTS Strategy Analysis</h3>
            <div class="simulation-info">
                Uses <strong>Monte Carlo Tree Search</strong> to find optimal actions. Each action is evaluated by simulating
                <strong>~10,000 games to terminal per action</strong>, accounting for observations (shrink/crit).
                <br><span style="color: #6f6;">GUARANTEED SAFE</span> = survives worst-case mass.
                <span style="color: #8af;">Success %</span> = probability of closing hole without rollout.
            </div>
            <div id="sim-status" style="color: #8af; margin-bottom: 10px;"></div>
            <div class="sequence-grid" id="sequence-grid">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- 5. PREDICTIONS: Conservative estimates -->
        <div class="prediction">
            <h3>5. Conservative Predictions (Worst-Case)</h3>
            <div class="prediction-grid">
                <div class="prediction-item">
                    <div class="label">Safe Hot/Hot Passes</div>
                    <div class="value" id="passes-safe">-</div>
                </div>
                <div class="prediction-item">
                    <div class="label">Min Mass After Next Hot/Hot</div>
                    <div class="value" id="mass-after-next">-</div>
                </div>
                <div class="prediction-item">
                    <div class="label">Next Hot/Hot Safe?</div>
                    <div class="value" id="next-safe">-</div>
                </div>
                <div class="prediction-item">
                    <div class="label">Rollout Risk Next Pass</div>
                    <div class="value" id="rollout-risk">-</div>
                </div>
            </div>
        </div>

        <!-- 6. REFERENCE: WH specs -->
        <div class="wh-specs">
            <div class="spec-card">
                <h3>Wormhole Type</h3>
                <div class="value">C247</div>
                <div class="unit">Leads to C3</div>
            </div>
            <div class="spec-card">
                <h3>Total Mass</h3>
                <div class="value">2,000</div>
                <div class="unit">M (Â±10%: 1800-2200)</div>
            </div>
            <div class="spec-card">
                <h3>Battleship (Higgs)</h3>
                <div class="value">200 / 300</div>
                <div class="unit">M Cold / Hot</div>
            </div>
            <div class="spec-card">
                <h3>HIC (Devoter)</h3>
                <div class="value">30 / 134 / 1.5</div>
                <div class="unit">M Cold / Hot / Ent</div>
            </div>
        </div>

        <!-- 7. HISTORY: Log of actions -->
        <div class="history">
            <h3>Jump History</h3>
            <div style="margin-bottom: 10px;">
                <button class="btn-undo" onclick="undoLast()">Undo Last</button>
                <button class="btn-reset" onclick="resetCalculator()">Reset All</button>
            </div>
            <div class="history-list" id="history-list">
                <div class="history-item">
                    <span class="action">No jumps recorded</span>
                </div>
            </div>
        </div>

        <footer>
            EEDVR Wormhole Calculator | J215101 C247 Static<br>
            <a href="https://wiki.eveuniversity.org/Wormhole_attributes" target="_blank">EVE University Wormhole Guide</a>
        </footer>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            whType: 'C247',
            baseMass: 2000,
            variance: 0.10,
            maxJumpMass: 375,
            // Battleship (Higgs Megathron)
            bsCold: 200,
            bsHot: 300,
            // HIC (Devoter with Higgs)
            hicCold: 30,
            hicHot: 134,
            hicEnt: 1.5,
            // Thresholds
            shrinkThreshold: 0.50,
            critThreshold: 0.10,
            // MC settings
            simulations: 60000
        };

        // State
        let state = {
            massUsed: 0,
            history: [],
            hasUnknownMass: false,
            knownMinStart: CONFIG.baseMass * (1 - CONFIG.variance),
            knownMaxStart: CONFIG.baseMass * (1 + CONFIG.variance)
        };

        // Jump definitions for manual tracking
        const JUMPS = {
            // Battleship jumps
            'bs-cold-cold': { mass: CONFIG.bsCold * 2, label: 'BS Cold/Cold' },
            'bs-hot-hot': { mass: CONFIG.bsHot * 2, label: 'BS Hot/Hot' },
            'bs-cold-hot': { mass: CONFIG.bsCold + CONFIG.bsHot, label: 'BS Cold/Hot' },
            'bs-cold-one': { mass: CONFIG.bsCold, label: 'BS Cold One-Way' },
            'bs-hot-one': { mass: CONFIG.bsHot, label: 'BS Hot One-Way' },
            // HIC jumps
            'hic-cold-cold': { mass: CONFIG.hicCold * 2, label: 'HIC Cold/Cold' },
            'hic-hot-hot': { mass: CONFIG.hicHot * 2, label: 'HIC Hot/Hot' },
            'hic-ent-ent': { mass: CONFIG.hicEnt * 2, label: 'HIC Ent/Ent' },
            'hic-ent-one': { mass: CONFIG.hicEnt, label: 'HIC Ent One-Way' }
        };

        // Action types for MC simulation
        const ACTIONS = {
            'BS_HOT': { out: CONFIG.bsHot, back: CONFIG.bsHot, label: 'BS H/H', isHic: false },
            'BS_COLD': { out: CONFIG.bsCold, back: CONFIG.bsCold, label: 'BS C/C', isHic: false },
            'BS_MIXED': { out: CONFIG.bsHot, back: CONFIG.bsCold, label: 'BS H/C', isHic: false },
            'HIC_HOT': { out: CONFIG.hicHot, back: CONFIG.hicHot, label: 'HIC H/H', isHic: true },
            'HIC_COLD': { out: CONFIG.hicCold, back: CONFIG.hicCold, label: 'HIC C/C', isHic: true },
            'HIC_ENT': { out: CONFIG.hicEnt, back: CONFIG.hicEnt, label: 'HIC E/E', isHic: true }
        };

        let recommendedStrategy = null;

        function init() {
            loadState();
            createStarfield();
            createWormholeEffect();
            // Run analysis asynchronously to not block UI
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 100);
        }

        function createStarfield() {
            const container = document.getElementById('stars');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createWormholeEffect() {
            const container = document.getElementById('wormhole-bg');
            const colors = ['#4af', '#84f', '#a4f', '#f4a', '#fa4'];
            for (let i = 0; i < 8; i++) {
                const ring = document.createElement('div');
                ring.className = 'wormhole-ring';
                const size = 100 + i * 80;
                ring.style.width = size + 'px';
                ring.style.height = size + 'px';
                ring.style.left = (400 - size/2) + 'px';
                ring.style.top = (400 - size/2) + 'px';
                ring.style.borderColor = colors[i % colors.length];
                ring.style.animationDelay = (i * 0.5) + 's';
                container.appendChild(ring);
            }
        }

        // MCTS Thresholds (remaining mass thresholds for visual state)
        const SHRINK_THRESHOLD = CONFIG.baseMass * CONFIG.shrinkThreshold;  // 1000 M
        const CRIT_THRESHOLD = CONFIG.baseMass * CONFIG.critThreshold;       // 200 M

        // Update belief based on observation (shrink/crit)
        // originalMass is the true total mass of the hole, trueRemaining is current remaining
        function updateBeliefWithObservation(belief, originalMass, trueRemaining, prevRemaining) {
            const newBelief = { min: belief.min, max: belief.max };

            // Calculate thresholds based on actual original mass
            const shrinkThresh = originalMass * CONFIG.shrinkThreshold;
            const critThresh = originalMass * CONFIG.critThreshold;

            // Check if we crossed shrink threshold (from above to below)
            if (prevRemaining > shrinkThresh && trueRemaining <= shrinkThresh && trueRemaining > critThresh) {
                // Observed shrink: remaining is now 10-50% of original
                // This means original was such that trueRemaining is in [10%, 50%] of it
                // We can narrow our belief about remaining
                newBelief.min = Math.max(newBelief.min, critThresh * 0.9);
                newBelief.max = Math.min(newBelief.max, shrinkThresh * 1.1);
            }

            // Check if we crossed crit threshold
            if (prevRemaining > critThresh && trueRemaining <= critThresh) {
                // Observed crit: remaining is now 0-10% of original
                newBelief.min = Math.max(newBelief.min, 0);
                newBelief.max = Math.min(newBelief.max, critThresh * 1.1);
            }

            return newBelief;
        }

        // Pick action for simulation rollout (heuristic: prefer higher mass that seems safe)
        function pickSimulationAction(belief) {
            const actionList = Object.entries(ACTIONS)
                .map(([key, act]) => ({ key, act, mass: act.out + act.back }))
                .sort((a, b) => b.mass - a.mass);  // Highest mass first

            // Pick highest mass action where we have a decent chance
            for (const { key, act } of actionList) {
                // If average remaining > outbound mass, consider it
                const avgRemaining = (belief.min + belief.max) / 2;
                if (avgRemaining > act.out * 1.5) {
                    return key;
                }
            }

            // Fall back to safest option
            for (const { key, act } of actionList.reverse()) {
                if (belief.max > act.out) {
                    return key;
                }
            }

            return null;
        }

        // Simulate from taking a specific first action until terminal
        // Returns { success: bool, steps: number }
        function simulateFromAction(firstActionKey, belief, originalMass, trueMass) {
            let remaining = trueMass;
            let currentBelief = { min: belief.min, max: belief.max };
            let steps = 1;

            // Execute first action
            const firstAct = ACTIONS[firstActionKey];

            // Outbound jump
            const prevRemaining = remaining;
            remaining -= firstAct.out;
            if (remaining <= 0) {
                return { success: false, steps };  // Rollout on first action
            }

            // Check for observation after outbound (before return)
            // Note: observation happens when we're on the other side and see the hole state
            currentBelief = updateBeliefWithObservation(currentBelief, originalMass, remaining, prevRemaining);
            currentBelief.min = Math.max(0, currentBelief.min - firstAct.out);
            currentBelief.max = Math.max(0, currentBelief.max - firstAct.out);

            // Return jump
            remaining -= firstAct.back;
            currentBelief.min = Math.max(0, currentBelief.min - firstAct.back);
            currentBelief.max = Math.max(0, currentBelief.max - firstAct.back);

            if (remaining <= 0) {
                return { success: true, steps };  // Collapsed on return - home safe
            }

            // Continue with more actions until terminal
            while (remaining > 0 && steps < 30) {
                const actionKey = pickSimulationAction(currentBelief);
                if (!actionKey) break;

                const act = ACTIONS[actionKey];
                steps++;

                // Outbound
                const prev = remaining;
                remaining -= act.out;
                if (remaining <= 0) {
                    return { success: false, steps };  // Rollout
                }

                // Update belief with observation
                currentBelief = updateBeliefWithObservation(currentBelief, originalMass, remaining, prev);
                currentBelief.min = Math.max(0, currentBelief.min - act.out);
                currentBelief.max = Math.max(0, currentBelief.max - act.out);

                // Return
                remaining -= act.back;
                currentBelief.min = Math.max(0, currentBelief.min - act.back);
                currentBelief.max = Math.max(0, currentBelief.max - act.back);

                if (remaining <= 0) {
                    return { success: true, steps };  // Home safe
                }
            }

            return { success: true, steps };  // Didn't collapse but no more actions
        }

        // MCTS: Evaluate an action by running many simulations to terminal
        function evaluateActionMCTS(actionKey, belief, startMin, startMax, massUsed, numSims) {
            const act = ACTIONS[actionKey];
            let successes = 0;
            let totalSteps = 0;

            for (let i = 0; i < numSims; i++) {
                // Sample true original mass and calculate true remaining
                const originalMass = startMin + Math.random() * (startMax - startMin);
                const trueMass = originalMass - massUsed;

                // Check immediate rollout
                if (trueMass <= act.out) {
                    // Would roll out on this action
                    continue;
                }

                const result = simulateFromAction(actionKey, belief, originalMass, trueMass);
                if (result.success) {
                    successes++;
                    totalSteps += result.steps;
                }
            }

            return {
                successRate: successes / numSims,
                rolloutRate: 1 - (successes / numSims),
                avgSteps: successes > 0 ? totalSteps / successes : Infinity,
                successes,
                total: numSims
            };
        }

        // Find the best action using MCTS
        function findBestActionMCTS(belief, startMin, startMax, massUsed) {
            const simsPerAction = Math.floor(CONFIG.simulations / Object.keys(ACTIONS).length);
            const results = [];

            for (const [key, act] of Object.entries(ACTIONS)) {
                // Skip actions that can't possibly succeed (max remaining < outbound)
                if (belief.max <= act.out) continue;

                const eval_result = evaluateActionMCTS(key, belief, startMin, startMax, massUsed, simsPerAction);
                results.push({
                    key,
                    act,
                    ...eval_result,
                    mass: act.out + act.back,
                    guaranteedSafe: belief.min > act.out
                });
            }

            // Sort by: prefer higher mass when success rates are comparable
            // Logic: Among "safe enough" actions (>= 99% success), prefer higher mass
            // Only sacrifice mass for significantly better success rate
            results.sort((a, b) => {
                const SAFE_THRESHOLD = 0.99;  // 99% success = "safe enough"
                const aIsSafe = a.successRate >= SAFE_THRESHOLD;
                const bIsSafe = b.successRate >= SAFE_THRESHOLD;

                // If both are safe, prefer higher mass (faster rolling)
                if (aIsSafe && bIsSafe) {
                    return b.mass - a.mass;
                }

                // If only one is safe, prefer the safe one
                if (aIsSafe !== bIsSafe) {
                    return bIsSafe - aIsSafe;
                }

                // If neither is safe, prefer higher success rate, then higher mass
                if (Math.abs(b.successRate - a.successRate) > 0.01) {
                    return b.successRate - a.successRate;
                }
                return b.mass - a.mass;
            });

            return results;
        }

        // Build recommended sequence using MCTS (greedy on MCTS results)
        function buildMCTSStrategy(belief, startMin, startMax, massUsed) {
            const sequence = [];
            let currentBelief = { min: belief.min, max: belief.max };
            let currentMassUsed = massUsed;

            while (currentBelief.min > 0 && sequence.length < 15) {
                // Find best action for current state
                const results = findBestActionMCTS(currentBelief, startMin, startMax, currentMassUsed);

                if (results.length === 0 || results[0].successRate < 0.5) break;

                const best = results[0];
                sequence.push(best.key);

                // Update state for next iteration
                const act = ACTIONS[best.key];
                currentBelief.min = Math.max(0, currentBelief.min - act.out - act.back);
                currentBelief.max = Math.max(0, currentBelief.max - act.out - act.back);
                currentMassUsed += act.out + act.back;
            }

            return sequence;
        }

        // Main MCTS analysis function
        function runStrategyAnalysis() {
            const statusEl = document.getElementById('sim-status');
            statusEl.textContent = 'Running MCTS analysis...';

            const startMin = state.knownMinStart;
            const startMax = state.knownMaxStart;
            const massUsed = state.massUsed;
            const minRemaining = startMin - massUsed;
            const maxRemaining = startMax - massUsed;

            const belief = { min: minRemaining, max: maxRemaining };

            // Find best actions using MCTS
            const actionResults = findBestActionMCTS(belief, startMin, startMax, massUsed);

            // Build recommended sequence
            const sequence = actionResults.length > 0
                ? buildMCTSStrategy(belief, startMin, startMax, massUsed)
                : [];

            // Get the best next action
            const nextAction = actionResults.length > 0 ? actionResults[0] : null;

            recommendedStrategy = {
                sequence,
                actionResults,
                nextAction,
                minRemaining,
                maxRemaining,
                belief
            };

            statusEl.textContent = `MCTS: ${CONFIG.simulations.toLocaleString()} simulations across ${actionResults.length} actions`;

            displayStrategyAnalysis();
        }

        // Display the strategy analysis
        function displayStrategyAnalysis() {
            const grid = document.getElementById('sequence-grid');
            grid.innerHTML = '';

            if (!recommendedStrategy) return;

            const { sequence, actionResults, nextAction, minRemaining, maxRemaining } = recommendedStrategy;

            // Card 1: Next Recommended Action (prominent)
            const nextCard = document.createElement('div');
            nextCard.style.gridColumn = '1 / -1';
            nextCard.style.borderWidth = '3px';

            if (nextAction) {
                const act = nextAction.act;
                const totalMass = act.out + act.back;
                const successPct = (nextAction.successRate * 100).toFixed(2);
                const rolloutPct = (nextAction.rolloutRate * 100).toFixed(3);

                const isHighSuccess = nextAction.successRate >= 0.99;
                nextCard.className = `sequence-card ${isHighSuccess ? 'safe' : (nextAction.successRate >= 0.95 ? 'risky' : 'dangerous')}`;

                nextCard.innerHTML = `
                    <div class="sequence-name" style="font-size: 1.3em;">
                        RECOMMENDED: ${act.label}
                        ${nextAction.guaranteedSafe ? '<span class="foolproof-badge">GUARANTEED SAFE</span>' : ''}
                        ${nextAction.successRate >= 0.9999 ? '<span class="foolproof-badge">~0% ROLLOUT</span>' : ''}
                    </div>
                    <div class="sequence-detail" style="font-size: 1.1em; color: ${isHighSuccess ? '#8f8' : '#fc8'}; margin: 10px 0;">
                        ${successPct}% success rate (${nextAction.successes.toLocaleString()}/${nextAction.total.toLocaleString()} simulations)
                    </div>
                    <div class="sequence-detail">
                        Round trip uses ${totalMass} M (${act.out} M out, ${act.back} M back)
                    </div>
                    <div class="sequence-detail">
                        Avg ${nextAction.avgSteps.toFixed(1)} round trips to close hole
                    </div>
                    ${!nextAction.guaranteedSafe ? `<div class="sequence-detail" style="color: #fc8;">Rollout risk: ${rolloutPct}%</div>` : ''}
                `;
            } else {
                nextCard.className = 'sequence-card dangerous';
                nextCard.innerHTML = `
                    <div class="sequence-name" style="font-size: 1.3em; color: #f88;">
                        NO SAFE ACTIONS AVAILABLE
                    </div>
                    <div class="sequence-detail" style="color: #faa;">
                        Worst-case remaining mass (${Math.round(minRemaining)} M) is too low for any round trip.
                        Consider a one-way pass or accept rollout risk.
                    </div>
                `;
            }
            grid.appendChild(nextCard);

            // Card 2: Full recommended sequence (if available)
            if (sequence.length > 0) {
                const seqCard = document.createElement('div');
                seqCard.className = 'sequence-card';

                const totalMass = sequence.reduce((sum, key) => {
                    const act = ACTIONS[key];
                    return sum + act.out + act.back;
                }, 0);

                const seqStr = sequence.map(a => ACTIONS[a].label).join(' â†’ ');

                seqCard.innerHTML = `
                    <div class="sequence-name">
                        MCTS Strategy: ${sequence.length} round trips
                    </div>
                    <div class="sequence-detail" style="font-size: 0.95em; color: #ccc; line-height: 1.4;">${seqStr}</div>
                    <div class="sequence-detail">Total mass: ${totalMass} M</div>
                    <div class="sequence-detail" style="color: #8af;">
                        Each step chosen by MCTS based on highest success rate to terminal
                    </div>
                `;
                grid.appendChild(seqCard);
            }

            // Card 3: Action comparison table (from MCTS results)
            if (actionResults.length > 0) {
                const compareCard = document.createElement('div');
                compareCard.className = 'sequence-card';
                compareCard.style.background = 'rgba(30, 35, 50, 0.9)';

                let tableRows = '';
                for (const result of actionResults) {
                    const act = result.act;
                    const mass = act.out + act.back;
                    const successPct = (result.successRate * 100).toFixed(2);
                    const statusColor = result.guaranteedSafe ? '#8f8' :
                                       (result.successRate >= 0.99 ? '#aef' :
                                       (result.successRate >= 0.95 ? '#fc8' : '#f88'));

                    tableRows += `
                        <tr style="border-bottom: 1px solid #3a3a5a;">
                            <td style="padding: 6px; color: #ccc;">${act.label}</td>
                            <td style="padding: 6px; text-align: right;">${mass} M</td>
                            <td style="padding: 6px; text-align: right;">${result.avgSteps.toFixed(1)}</td>
                            <td style="padding: 6px; text-align: right; color: ${statusColor}; font-weight: bold;">
                                ${successPct}%
                                ${result.guaranteedSafe ? ' âœ“' : ''}
                            </td>
                        </tr>
                    `;
                }

                compareCard.innerHTML = `
                    <div class="sequence-name">All Actions - MCTS Analysis</div>
                    <div class="sequence-detail" style="margin-bottom: 8px;">
                        Success rate = probability of closing hole without rollout (simulated to terminal)
                    </div>
                    <table style="width: 100%; font-size: 0.9em; margin-top: 10px;">
                        <tr style="color: #888; border-bottom: 1px solid #4a4a6a;">
                            <th style="padding: 6px; text-align: left;">Action</th>
                            <th style="padding: 6px; text-align: right;">Mass</th>
                            <th style="padding: 6px; text-align: right;">Avg Steps</th>
                            <th style="padding: 6px; text-align: right;">Success</th>
                        </tr>
                        ${tableRows}
                    </table>
                `;
                grid.appendChild(compareCard);
            }
        }

        function recordJump(type) {
            const jump = JUMPS[type];
            state.massUsed += jump.mass;
            state.history.push({
                type: type,
                label: jump.label,
                mass: jump.mass,
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function recoverFromShrink() {
            state.massUsed = 0;
            state.knownMinStart = CONFIG.baseMass * (1 - CONFIG.variance) * CONFIG.critThreshold;
            state.knownMaxStart = CONFIG.baseMass * (1 + CONFIG.variance) * CONFIG.shrinkThreshold;
            state.hasUnknownMass = true;
            state.history.push({
                type: 'recovery-shrink',
                label: 'Recovered: Hole Shrunk',
                mass: 0,
                note: 'Reset to shrink state (180-1100 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function recoverFromCrit() {
            state.massUsed = 0;
            state.knownMinStart = 0;
            state.knownMaxStart = CONFIG.baseMass * (1 + CONFIG.variance) * CONFIG.critThreshold;
            state.hasUnknownMass = true;
            state.history.push({
                type: 'recovery-crit',
                label: 'Recovered: Hole Crit',
                mass: 0,
                note: 'Reset to crit state (0-220 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        // State change observed while tracking - combine tracking data with state info
        function holeJustShrunk() {
            // Calculate current tracked range
            const trackedMin = state.knownMinStart - state.massUsed;
            const trackedMax = state.knownMaxStart - state.massUsed;

            // Shrink means remaining is 10%-50% of original (with variance)
            const shrinkMin = CONFIG.baseMass * (1 - CONFIG.variance) * CONFIG.critThreshold;  // 180 M
            const shrinkMax = CONFIG.baseMass * (1 + CONFIG.variance) * CONFIG.shrinkThreshold; // 1100 M

            // Intersect the ranges
            let newMin = Math.max(trackedMin, shrinkMin);
            let newMax = Math.min(trackedMax, shrinkMax);
            let note;

            // Handle invalid intersection (tracking was wrong)
            if (newMin > newMax) {
                newMin = shrinkMin;
                newMax = shrinkMax;
                note = `Tracking inconsistent, reset to ${Math.round(shrinkMin)}-${Math.round(shrinkMax)} M`;
            } else {
                note = `Narrowed to ${Math.round(newMin)}-${Math.round(newMax)} M`;
            }

            // Reset massUsed and set new narrower starting range
            state.massUsed = 0;
            state.knownMinStart = newMin;
            state.knownMaxStart = newMax;
            state.hasUnknownMass = false;

            state.history.push({
                type: 'state-shrunk',
                label: 'Hole Shrunk (Combined)',
                mass: 0,
                note: note,
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function holeJustCrit() {
            // Calculate current tracked range
            const trackedMin = state.knownMinStart - state.massUsed;
            const trackedMax = state.knownMaxStart - state.massUsed;

            // Crit means remaining is 0%-10% of original (with variance)
            const critMin = 0;
            const critMax = CONFIG.baseMass * (1 + CONFIG.variance) * CONFIG.critThreshold; // 220 M

            // Intersect the ranges
            let newMin = Math.max(trackedMin, critMin);
            let newMax = Math.min(trackedMax, critMax);
            let note;

            // Handle invalid intersection (tracking was wrong)
            if (newMin > newMax) {
                newMin = critMin;
                newMax = critMax;
                note = `Tracking inconsistent, reset to ${Math.round(critMin)}-${Math.round(critMax)} M`;
            } else {
                note = `Narrowed to ${Math.round(newMin)}-${Math.round(newMax)} M`;
            }

            state.massUsed = 0;
            state.knownMinStart = newMin;
            state.knownMaxStart = newMax;
            state.hasUnknownMass = false;

            state.history.push({
                type: 'state-crit',
                label: 'Hole Crit (Combined)',
                mass: 0,
                note: note,
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function setFreshHole() {
            state.massUsed = 0;
            state.knownMinStart = CONFIG.baseMass * (1 - CONFIG.variance);
            state.knownMaxStart = CONFIG.baseMass * (1 + CONFIG.variance);
            state.hasUnknownMass = false;
            state.history = [];
            state.history.push({
                type: 'setup-fresh',
                label: 'New Fresh Hole',
                mass: 0,
                note: 'Fresh spawn (1800-2200 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function setUnknownFresh() {
            state.massUsed = 0;
            state.knownMinStart = CONFIG.baseMass * (1 - CONFIG.variance) * CONFIG.shrinkThreshold;
            state.knownMaxStart = CONFIG.baseMass * (1 + CONFIG.variance);
            state.hasUnknownMass = true;
            state.history = [];
            state.history.push({
                type: 'setup-unknown-fresh',
                label: 'Unknown Mass (Still Fresh)',
                mass: 0,
                note: 'Unknown but >50% (900-2200 M)',
                timestamp: new Date().toLocaleTimeString()
            });
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function applyKnownMass() {
            const input = document.getElementById('known-mass-input');
            const knownMass = parseFloat(input.value);

            if (isNaN(knownMass) || knownMass < 0) {
                alert('Please enter a valid mass value (in M)');
                return;
            }

            state.massUsed = knownMass;
            state.knownMinStart = CONFIG.baseMass * (1 - CONFIG.variance);
            state.knownMaxStart = CONFIG.baseMass * (1 + CONFIG.variance);
            state.hasUnknownMass = false;
            state.history = [];
            state.history.push({
                type: 'setup-known-mass',
                label: 'Known Mass Applied',
                mass: knownMass,
                note: 'Imported ' + knownMass + ' M from tracker',
                timestamp: new Date().toLocaleTimeString()
            });

            input.value = '';
            saveState();
            setTimeout(() => {
                runStrategyAnalysis();
                updateDisplay();
            }, 10);
        }

        function undoLast() {
            if (state.history.length > 0) {
                const last = state.history.pop();
                if (last.type.startsWith('recovery') || last.type.startsWith('setup')) {
                    alert('Setup/recovery actions cannot be undone. Use a new setup instead.');
                    state.history.push(last);
                } else {
                    state.massUsed -= last.mass;
                }
                saveState();
                setTimeout(() => {
                    runStrategyAnalysis();
                    updateDisplay();
                }, 10);
            }
        }

        function resetCalculator() {
            if (confirm('Reset all tracking? This cannot be undone.')) {
                state = {
                    massUsed: 0,
                    history: [],
                    hasUnknownMass: false,
                    knownMinStart: CONFIG.baseMass * (1 - CONFIG.variance),
                    knownMaxStart: CONFIG.baseMass * (1 + CONFIG.variance)
                };
                saveState();
                setTimeout(() => {
                    runStrategyAnalysis();
                    updateDisplay();
                }, 10);
            }
        }

        function updateDisplay() {
            const minRemaining = Math.max(0, state.knownMinStart - state.massUsed);
            const maxRemaining = Math.max(0, state.knownMaxStart - state.massUsed);
            const avgRemaining = (minRemaining + maxRemaining) / 2;

            // Update mass bar
            const massBar = document.getElementById('mass-bar');
            const avgPercent = (avgRemaining / CONFIG.baseMass) * 100;
            massBar.style.width = avgPercent + '%';

            // Update variance overlay
            const overlay = document.getElementById('variance-overlay');
            const minPercent = (minRemaining / (CONFIG.baseMass * 1.1)) * 100;
            const maxPercent = (maxRemaining / (CONFIG.baseMass * 1.1)) * 100;
            overlay.style.left = minPercent + '%';
            overlay.style.width = (maxPercent - minPercent) + '%';

            // Variance labels
            document.getElementById('var-min-label').textContent = Math.round(minRemaining) + ' M';
            document.getElementById('var-max-label').textContent = Math.round(maxRemaining) + ' M';

            // Determine status based on average
            let status, statusClass;
            if (avgRemaining <= CONFIG.baseMass * CONFIG.critThreshold) {
                status = 'CRITICAL';
                statusClass = 'crit';
            } else if (avgRemaining <= CONFIG.baseMass * CONFIG.shrinkThreshold) {
                status = 'SHRUNK';
                statusClass = 'shrink';
            } else {
                status = 'FRESH';
                statusClass = 'fresh';
            }

            massBar.className = 'mass-bar ' + statusClass;
            document.getElementById('status-badge').className = 'status-badge status-' + statusClass;
            document.getElementById('status-badge').textContent = status;

            // Update displays
            document.getElementById('mass-remaining').textContent = Math.round(avgRemaining) + ' M';
            document.getElementById('range-min').textContent = Math.round(minRemaining);
            document.getElementById('range-max').textContent = Math.round(maxRemaining);

            // Update predictions (worst-case)
            updatePredictions(minRemaining, maxRemaining);
            updateHistory();
        }

        function updatePredictions(minRemaining, maxRemaining) {
            const bsHotHot = CONFIG.bsHot * 2;

            // Safe BS hot/hot passes
            let safePasses = 0;
            let testMass = minRemaining;
            while (testMass > bsHotHot) {
                testMass -= bsHotHot;
                safePasses++;
            }

            document.getElementById('passes-safe').textContent = safePasses + ' BS Hot/Hot';
            document.getElementById('passes-safe').className = 'value ' + (safePasses > 0 ? 'safe' : 'warning');

            // Mass after next hot/hot (worst case)
            const minAfterNext = minRemaining - bsHotHot;
            document.getElementById('mass-after-next').textContent = Math.round(minAfterNext) + ' M';
            document.getElementById('mass-after-next').className = 'value ' + (minAfterNext > 0 ? 'safe' : 'warning');

            // Next hot/hot safe?
            const nextSafe = minAfterNext > 0;
            document.getElementById('next-safe').textContent = nextSafe ? 'YES' : 'NO - USE HIC';
            document.getElementById('next-safe').className = 'value ' + (nextSafe ? 'safe' : 'warning');

            // Rollout risk for next BS hot pass
            let rollouts = 0;
            const sims = 10000;
            for (let i = 0; i < sims; i++) {
                const actualRemaining = minRemaining + Math.random() * (maxRemaining - minRemaining);
                if (actualRemaining - CONFIG.bsHot <= 0) {
                    rollouts++;
                }
            }
            const riskPercent = ((rollouts / sims) * 100).toFixed(1);
            document.getElementById('rollout-risk').textContent = riskPercent + '%';
            document.getElementById('rollout-risk').className = 'value ' + (rollouts === 0 ? 'safe' : 'warning');
        }

        function updateHistory() {
            const container = document.getElementById('history-list');

            if (state.history.length === 0) {
                container.innerHTML = '<div class="history-item"><span class="action">No jumps recorded</span></div>';
                return;
            }

            container.innerHTML = state.history.slice().reverse().map(item => {
                const massClass = item.type.startsWith('recovery') ? 'recovery' : 'negative';
                const massDisplay = item.type.startsWith('recovery')
                    ? item.note
                    : ('-' + item.mass + ' M');

                return `
                    <div class="history-item">
                        <span class="action">${item.timestamp} - ${item.label}</span>
                        <span class="mass-change ${massClass}">${massDisplay}</span>
                    </div>
                `;
            }).join('');
        }

        function saveState() {
            localStorage.setItem('eedvr-wh-calc-v2', JSON.stringify(state));
        }

        function loadState() {
            const saved = localStorage.getItem('eedvr-wh-calc-v2');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    state = {
                        ...state,
                        ...loaded
                    };
                } catch (e) {
                    console.error('Failed to load saved state');
                }
            }
        }

        window.onload = init;
    </script>
</body>
</html>
